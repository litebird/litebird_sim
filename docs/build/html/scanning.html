
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Scanning strategy &#8212; LBS 0.13.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="_static/asciinema-player_2.6.1.css" />
    <link rel="stylesheet" type="text/css" href="_static/asciinema-custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="_static/contentui.css" />
  
  <!-- So that users can add custom icons -->
  <script src="_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="_static/documentation_options.js?v=1019fba8"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/asciinema-player_2.6.1.js"></script>
    <script src="_static/contentui.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'scanning';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Quaternions" href="quaternions.html" />
    <link rel="prev" title="Basic simulation modules" href="part3.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
  
    <p class="title logo__title">LBS 0.13.0 documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="part1.html">
    Introduction
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="part2.html">
    Structure of the framework
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="part3.html">
    Basic simulation modules
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="part4.html">
    Systematic effects
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="part5.html">
    Data-reduction modules
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="part6.html">
    Tutorials
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="appendix.html">
    Appendices
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="installation.html">
    Installation
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="part1.html">
    Introduction
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="part2.html">
    Structure of the framework
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="part3.html">
    Basic simulation modules
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="part4.html">
    Systematic effects
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="part5.html">
    Data-reduction modules
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="part6.html">
    Tutorials
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="appendix.html">
    Appendices
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="installation.html">
    Installation
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Scanning strategy</a></li>
<li class="toctree-l1"><a class="reference internal" href="quaternions.html">Quaternions</a></li>
<li class="toctree-l1"><a class="reference internal" href="hwp.html">Ideal Half Wave Plate</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">Instrumental noise</a></li>
<li class="toctree-l1"><a class="reference internal" href="sky_maps.html">Synthetic sky maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="dipole.html">Dipole anisotropy</a></li>
<li class="toctree-l1"><a class="reference internal" href="map_scanning.html">Scanning a map to fill a TOD</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="part3.html" class="nav-link">Basic simulation modules</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">Scanning strategy</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="scanning-strategy">
<span id="id1"></span><h1>Scanning strategy<a class="headerlink" href="#scanning-strategy" title="Link to this heading">#</a></h1>
<p>The LiteBIRD Simulation Framework provides a set of tools to simulate
the orbit of the spacecraft and compute the directions where each
detector is looking at the sky as a function of time. The time stream
of directions and orientations of each detector is usually called
<em>pointing information</em>, and we will consistently use this jargon in
the documentation.</p>
<p>Note that this chapter only deals with the <em>direction</em> along which
some detector is looking, but the actual position/velocity of the
spacecraft is optional when doing this calculation. The framework
provides other facilities to compute this information, and they are
described in <a class="reference internal" href="dipole.html#dipole-anisotropy"><span class="std std-ref">Dipole anisotropy</span></a>.</p>
<p>This chapter provides an in-depth explanation of how to use the
facilities provided by the framework to compute the pointing
information for any detector in one of the focal planes.</p>
<section id="the-motion-of-the-spacecraft">
<h2>The motion of the spacecraft<a class="headerlink" href="#the-motion-of-the-spacecraft" title="Link to this heading">#</a></h2>
<p>In the case of a space mission like LiteBIRD, the motion of the
spacecraft and its structure decide where each detector is looking at
each time. The following video depicts the kind of motion simulated by
our framework:</p>
<iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/Nh7pMSrVDZs"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen>
</iframe><p>(The animation was created using <a class="reference external" href="http://povray.org/">POV-Ray</a>, and
the files used to create it are available on <a class="reference external" href="https://github.com/ziotom78/povray_scanning_strategy">GitHub</a> .)</p>
<p>You can see that there are <em>two</em> rotations in the animation: the
spacecraft spins quickly around its spin axis (grey axis), but this
axis does not stand still: it performs a precession around the blue
axis, which represents the Sun-Earth direction. (You should imagine
the Earth on the left and the Sun on the far left.)</p>
<p>Note that the detectors are not necessarily aligned with the spin
axis; in fact, the animation shows the actual direction of observation
for two different detectors as two red and green lines: you can see
that they are looking at two opposite sides of the spin axis. Every
detector looks along its direction, but detectors belonging to the
same instrument (e.g., LFT) look not far away from each other; it is
customary to express their pointing directions relative to an
«average» direction, called the <em>boresight direction</em>, which is the
main optical axis of the instrument. In LiteBIRD, there are <em>three</em>
instruments (LFT, MFT, HFT), so there should be <em>three</em> boresight
directions; however, MFT and HFT share the same telescope, and thus it
is customary to show only one boresight for both. This is the true
meaning of the red and green axes in the video above: the red axis
represents the «average» direction where LFT detectors are looking,
and the green axis is the same for MFT/HFT.</p>
<p>The animation does not show a <em>third</em> rotation happening, which is the
revolution of the spacecraft around the Sun, taking one year to
complete. (Including it in the video would have been useless, as it is
<em>really</em> slow when compared with the spin and precession!). Thus, the
motion of the spacecraft is the composition of <em>three</em> rotations:</p>
<ol class="arabic simple">
<li><p>Rotation of the spacecraft around the spin axis (grey line);</p></li>
<li><p>Rotation (precession) of the spin axis around the Sun-Earth axis
(blue line);</p></li>
<li><p>Yearly rotation of the Sun-Earth axis around the Sun.</p></li>
</ol>
<p>If you think about it, you will realize that the following quantities
can fully describe the kinematics of this motion:</p>
<ul class="simple">
<li><p>The angle between the spin axis and the boresight direction(s),
usually called β;</p></li>
<li><p>The angle between the spin and Sun-Earth axes is usually called α.</p></li>
<li><p>The speed of the rotation of the boresight direction around the spin
axis;</p></li>
<li><p>The speed of the precession around the Sun-Earth axis, which is
usually slower than the rotation speed;</p></li>
</ul>
<p>They are sketched in the following diagram:</p>
<img alt="_images/litebird-scanning-strategy.svg" src="_images/litebird-scanning-strategy.svg" />
<p>These parameters define the so-called <em>scanning strategy</em>, i.e., how
the instruments observe the sky during the mission lifetime. The
LiteBIRD Simulation Framework provides all the tools necessary to
simulate the composition of these rotations, and it can produce
pointing information from the synthetic description of the scanning
strategy. Here is a complete example using the scanning strategy
proposed for CORE (<span id="id2">[<a class="reference internal" href="bibliography.html#id2" title="J. Delabrouille and The CORE collaboration. Exploring cosmic origins with CORE: Survey requirements and mission design. JCAP, 2018(4):014, April 2018. arXiv:1706.04516, doi:10.1088/1475-7516/2018/04/014.">3</a>]</span>), which is
qualitatively similar to what is going to be used for LiteBIRD:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">litebird_sim</span> <span class="k">as</span> <span class="nn">lbs</span>
<span class="kn">import</span> <span class="nn">astropy.units</span> <span class="k">as</span> <span class="nn">u</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">sim</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span>
    <span class="n">start_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">duration_s</span><span class="o">=</span><span class="mf">60.0</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Simple simulation&quot;</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">12345</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># We now simulate the motion of the spacecraft over a time span</span>
<span class="c1"># of one minute (specified in the `duration_s` parameter above).</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_scanning_strategy</span><span class="p">(</span>
    <span class="n">scanning_strategy</span><span class="o">=</span><span class="n">lbs</span><span class="o">.</span><span class="n">SpinningScanningStrategy</span><span class="p">(</span>
        <span class="n">spin_sun_angle_rad</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="c1"># CORE-specific parameter</span>
        <span class="n">spin_rate_hz</span><span class="o">=</span><span class="mf">0.5</span> <span class="o">/</span> <span class="mf">60.0</span><span class="p">,</span>     <span class="c1"># Ditto</span>
        <span class="c1"># We use astropy to convert the period (4 days) in</span>
        <span class="c1"># seconds</span>
        <span class="n">precession_rate_hz</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="c1"># Here we specify the β angle of the focal plane of</span>
<span class="c1"># the instrument</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_instrument</span><span class="p">(</span>
    <span class="n">lbs</span><span class="o">.</span><span class="n">InstrumentInfo</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;core&quot;</span><span class="p">,</span>
        <span class="n">spin_boresight_angle_rad</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">65</span><span class="p">),</span>
    <span class="p">),</span>
<span class="p">)</span>

<span class="c1"># We include a fake boresight detector `det`, belonging</span>
<span class="c1"># to the instrument `core` (unlike LiteBIRD, CORE had only one focal</span>
<span class="c1"># plane and one instrument)</span>
<span class="n">det</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">DetectorInfo</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">sampling_rate_hz</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># By default, `create_observations` creates just *one* observation</span>
<span class="n">obs</span><span class="p">,</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">create_observations</span><span class="p">(</span><span class="n">detectors</span><span class="o">=</span><span class="p">[</span><span class="n">det</span><span class="p">])</span>

<span class="c1"># Prepare the quaternions needed to compute the pointings, i.e.,</span>
<span class="c1"># the direction in the sky where the detector is looking at as</span>
<span class="c1"># a function of time</span>
<span class="n">sim</span><span class="o">.</span><span class="n">prepare_pointings</span><span class="p">()</span>

<span class="c1"># `get_pointings()` returns both the pointing matrix and the</span>
<span class="c1"># HWP angle; we ignore the latter with `_`, as we do not have</span>
<span class="c1"># a HWP here. The pointing matrix contains the angles (θ, φ, ψ)</span>
<span class="c1"># for each sample in the TOD and each detector.</span>
<span class="n">pointings</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">get_pointings</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape:&quot;</span><span class="p">,</span> <span class="n">pointings</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Pointings:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_str</span><span class="p">(</span><span class="n">pointings</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Shape: (600, 3)
Pointings:
[[ 2.182 -0.    -1.571]
 [ 2.182 -0.006 -1.576]
 [ 2.182 -0.012 -1.582]
 ...
 [ 0.089 -2.967 -1.738]
 [ 0.088 -3.021 -1.687]
 [ 0.087 -3.075 -1.635]]
</pre></div>
</div>
<p>We explain all the details of this code in the following sections, so
for now, keep in mind the overall shape of the code:</p>
<ol class="arabic">
<li><p>Once we set the duration of the simulation (one minute in the
example above), we call the method
<a class="reference internal" href="simulations.html#litebird_sim.simulations.Simulation.set_scanning_strategy" title="litebird_sim.simulations.Simulation.set_scanning_strategy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Simulation.set_scanning_strategy()</span></code></a>, which forces the
framework to compute how the orientation of the spacecraft with
respect to the sky sphere evolves with time. This method produces a
set of quaternions, which encode the result of the composition of
all the rotations (spin, precession, revolution around the Sun)
described above; LBS saves these quaternions in the
<code class="docutils literal notranslate"><span class="pre">spin2ecliptic_quats</span></code> field of the <code class="docutils literal notranslate"><span class="pre">sim</span></code> class. For more
information about quaternions, see <a class="reference internal" href="quaternions.html#quaternions-chapter"><span class="std std-ref">Quaternions</span></a> .</p></li>
<li><p>When the simulation code needs to determine where a detector is
pointing to (the detector <code class="docutils literal notranslate"><span class="pre">det</span></code> in our example), it uses the
quaternions to retrieve (1) the coordinates on the Sky sphere,
and (2) the orientation angle (ψ). LBS computes both quantities in
the Ecliptic reference frame using the sampling rate of the
detector, which in our example is 10 Hz (i.e., ten samples per
second). In the example above, this is done by the function
<code class="xref py py-func docutils literal notranslate"><span class="pre">get_pointings()</span></code>.</p></li>
<li><p>The method <a class="reference internal" href="observations.html#litebird_sim.observations.Observation.get_pointings" title="litebird_sim.observations.Observation.get_pointings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Observation.get_pointings()</span></code></a> returns an array with
either 2 or 3 fields depending on the argument passed:</p>
<ul class="simple">
<li><p>if the caller passes an integer, LBS interprets this as the index
of the detector in the observation and returns a <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">3)</span></code>
matrix where the first column contains the colatitude
<span class="math notranslate nohighlight">\(\theta\)</span>, the second column the longitude <span class="math notranslate nohighlight">\(\phi\)</span>, and
the third column the orientation angle <span class="math notranslate nohighlight">\(\psi\)</span>. All the
angles are expressed in radians.</p></li>
<li><p>if the caller passes a list of indices, LBS interprets it as a
list of detectors in the observation for which the caller wants
to compute the pointing. It returns a <code class="docutils literal notranslate"><span class="pre">(D,</span> <span class="pre">N,</span> <span class="pre">3)</span></code> matrix where
D represents the detector index, N the index of the sample, and
the three final columns are the same described in the first case.</p></li>
<li><p>if the caller passes the string “all”, LBS returns a <code class="docutils literal notranslate"><span class="pre">(D,</span> <span class="pre">N,</span>
<span class="pre">3)</span></code> matrix containing the pointing information for all the
detectors in the observation.</p></li>
</ul>
<p>These angles are expressed in the Ecliptic Coordinate System, where
the Equator is aligned with the Ecliptic Plane of the Solar System.</p>
</li>
</ol>
</section>
<section id="computing-the-orientation-of-the-spacecraft">
<h2>Computing the orientation of the spacecraft<a class="headerlink" href="#computing-the-orientation-of-the-spacecraft" title="Link to this heading">#</a></h2>
<p>To compute where a detector is looking at the sky sphere, there is a
number of transformations that need to be carried out:</p>
<img alt="_images/coordinate-systems.svg" src="_images/coordinate-systems.svg" />
<p>We start from the detector reference frame, where the main beam of the
radiation pattern is aligned with the <cite>z</cite> axis and is oriented using
the <cite>x</cite> axis as the reference axis. (In other words, the <cite>x</cite> axis
provides a reference frame for asymmetric beams.)</p>
<p>The next reference frame is the <em>boresight</em>, and to convert from the
detector reference frame to the boresight there is a rotation, which
is encoded in a rotation quaternion that is saved in the IMO. The
framework implements the class <a class="reference internal" href="#litebird_sim.scanning.RotQuaternion" title="litebird_sim.scanning.RotQuaternion"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotQuaternion</span></code></a> to encode a
rotation quaternion; this class can also model time-varying rotations,
which can be useful to simulate vibrations and wobbles in the optical
structure of the instruments.</p>
<p>Next, we move from the reference frame of the boresight to that of the
spacecraft. The class <a class="reference internal" href="detectors.html#litebird_sim.detectors.InstrumentInfo" title="litebird_sim.detectors.InstrumentInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstrumentInfo</span></code></a> encodes the information
about the placement of the boresight with respect to the spin axis.
After this transformation, the spin axis is aligned with the <cite>z</cite> axis.</p>
<p>The next transformation goes from the spacecraft to the Ecliptic
reference frame; the Ecliptic is on the <cite>xy</cite> plane, and the <cite>z</cite> axis
points towards the Ecliptic North Pole. In this case, the framework
provides two ways to compute the transformation:</p>
<ol class="arabic">
<li><p>The revolution of the Earth around the Sun is modeled using a plain
circular motion, and the starting position is arbitrary; this mode
is triggered whenever the time is tracked using floating-point
numbers (i.e., the parameter <cite>start_time</cite> in the constructor of
<a class="reference internal" href="simulations.html#litebird_sim.simulations.Simulation" title="litebird_sim.simulations.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Simulation</span></code></a> is a <code class="docutils literal notranslate"><span class="pre">float</span></code>).</p></li>
<li><p>The proper motion of the Earth around the Sun is computed using
ephemeridis tables; the calculation is much slower, but the result
enables to properly simulate the observation of moving objects in
the Solar System, like planets or asteroids. In this case, the
parameter <cite>start_time</cite> must be an instance of the class
<code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code>. In the example above, we would enable the
computation of the proper motion of the Earth with the following
minor change:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">astropy.time</span>

<span class="n">sim</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span>
    <span class="c1"># Turn on full computation of the Earth orbit around the Sun</span>
    <span class="n">start_time</span><span class="o">=</span><span class="n">astropy</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="p">(</span><span class="s2">&quot;2020-01-01&quot;</span><span class="p">),</span>
    <span class="n">duration_s</span><span class="o">=</span><span class="mf">60.0</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Simple simulation&quot;</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">12345</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
<p>You should compute the proper motion of the Earth around the Sun only
if you need to, as it makes the computation of the pointing
information 10÷100 times slower.</p>
<section id="from-quaternions-to-detector-pointings">
<h3>From quaternions to detector pointings<a class="headerlink" href="#from-quaternions-to-detector-pointings" title="Link to this heading">#</a></h3>
<p>To compute the pointing information for a detector, the quaternions
computed through the call to <a class="reference internal" href="simulations.html#litebird_sim.simulations.Simulation.set_scanning_strategy" title="litebird_sim.simulations.Simulation.set_scanning_strategy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Simulation.set_scanning_strategy()</span></code></a>
are not enough, as they only tell how to convert a vector from the
<em>spin axis</em> reference frame to the Ecliptic reference frame. We need
two more quaternions that tell how to convert from the reference frame
of the detector to that of the spin axis:</p>
<ol class="arabic simple">
<li><p>The first quaternion describes how the detector reference frame
(with the <cite>z</cite> axis aligned with the main axis of the radiation
pattern) can be converted to the reference frame of the focal plane
(with the <cite>z</cite> axis aligned with the boresight). This information is
included in the IMO and is properly initialized if you call
<a class="reference internal" href="detectors.html#litebird_sim.detectors.DetectorInfo.from_imo" title="litebird_sim.detectors.DetectorInfo.from_imo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DetectorInfo.from_imo()</span></code></a>. If you do not specify any
quaternion, the constructor for <a class="reference internal" href="detectors.html#litebird_sim.detectors.DetectorInfo" title="litebird_sim.detectors.DetectorInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">DetectorInfo</span></code></a> will assume
that the detector is looking at the boresight. It will thus create
a default <a class="reference internal" href="#litebird_sim.scanning.RotQuaternion" title="litebird_sim.scanning.RotQuaternion"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotQuaternion</span></code></a> object, which corresponds to the
identity quaternion <span class="math notranslate nohighlight">\((0 0 0 1)\)</span>; this is the case of the
simple example we presented above.</p></li>
<li><p>The second quaternion describes how to convert the reference frame
of the focal plane (with the <cite>z</cite> axis aligned with the boresight)
to the reference frame of the spacecraft (where the <cite>z</cite> axis is
aligned with its spin axis). This quaternion is stored in the field
<code class="docutils literal notranslate"><span class="pre">bore2spin_quat</span></code> of the class <a class="reference internal" href="detectors.html#litebird_sim.detectors.InstrumentInfo" title="litebird_sim.detectors.InstrumentInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstrumentInfo</span></code></a>, and it is
initialized when you call the method
<a class="reference internal" href="simulations.html#litebird_sim.simulations.Simulation.set_scanning_strategy" title="litebird_sim.simulations.Simulation.set_scanning_strategy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Simulation.set_scanning_strategy()</span></code></a>.</p></li>
</ol>
<p>The LiteBIRD Simulation Framework recomputes the orientation of the
spacecraft with a regular spacing in time (the default is one minute).
However, pointings need to be known at the same sampling frequency
used by the detector, which is usually much higher than the frequency
used to compute the quaternions (in our example above, the sampling
frequency of detector <code class="docutils literal notranslate"><span class="pre">det</span></code> was 10 Hz, but the sampling frequency of
the quaternions was 1/60 Hz). Since the framework uses quaternions to
encode the orientation of the spacecraft, oversampling them to the
sampling frequency of the detector is just a matter of applying a
spherical linear interpolation (abbr. <a class="reference external" href="https://en.wikipedia.org/wiki/Slerp">slerp</a>), according to the following
figure:</p>
<img alt="_images/quaternion-sampling.svg" src="_images/quaternion-sampling.svg" />
<p>To be sure to include an additional quaternion <em>after</em> the last
sample, like in the figure above, the framework provides the static
method <a class="reference internal" href="#litebird_sim.scanning.ScanningStrategy.optimal_num_of_quaternions" title="litebird_sim.scanning.ScanningStrategy.optimal_num_of_quaternions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ScanningStrategy.optimal_num_of_quaternions()</span></code></a>, which
computes how many quaternions are needed to cover some period with a
given interval between quaternions. For instance, if our simulation
lasts 100 s and we want one quaternion every minute, then the number
of quaternions needed is 3: one at <span class="math notranslate nohighlight">\(t = 0\)</span>, one at <span class="math notranslate nohighlight">\(t =
60\,\mathrm{s}\)</span>, and one at <span class="math notranslate nohighlight">\(t = 120\,\mathrm{s}\)</span>, so that the
latter two can be interpolated for the samples in the range
<span class="math notranslate nohighlight">\(60\,\mathrm{s} \leq t \leq 100\,\mathrm{s}\)</span>. Here is how the
function works:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">lbs</span><span class="o">.</span><span class="n">ScanningStrategy</span><span class="o">.</span><span class="n">optimal_num_of_quaternions</span><span class="p">(</span>
    <span class="n">time_span_s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">delta_time_s</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span>
<span class="p">))</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
<p>When using MPI, the relatively small size in memory of the quaternions
(the thick black lines in the figure) enables the framework to keep
a duplicate of the list in all the MPI processes. This is unlike
what happens with the data in TODs (the thin gray lines), which are
split in several blocks inside the <a class="reference internal" href="observations.html#litebird_sim.observations.Observation" title="litebird_sim.observations.Observation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observation</span></code></a> class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Slerp assumes a rotation with constant angular speed and axis
between consecutive quaternions. Thus, it only approximates the
proper composition of all the rotations (spin, precession,
revolution around the Sun) that we discussed above. However,
remember that the <em>actual</em> spacecraft will follow a scanning
strategy that will be more complex than the one described by our
geometrical model because of many unavoidable non-idealities in a
spacecraft. The approximation of the «slerp» operation is thus
unlikely to be relevant.</p>
</div>
<p>Once LBS has all the quaternions sampled at the proper sampling rate,
it can compute the direction of the detector on the sky and its
orientation angle through <a class="reference internal" href="observations.html#litebird_sim.observations.Observation.get_pointings" title="litebird_sim.observations.Observation.get_pointings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Observation.get_pointings()</span></code></a>. The
calculation works as follows:</p>
<ul>
<li><p>The direction is the vector <span class="math notranslate nohighlight">\(\vec d = R \hat e_z\)</span>, where
<span class="math notranslate nohighlight">\(R\)</span> is the overall rotation from the detector reference frame
to the Ecliptic reference frame, and <span class="math notranslate nohighlight">\(\hat e_z = (0, 0, 1)\)</span> is
the one-length vector aligned with the <cite>z</cite> axis.</p></li>
<li><p>The orientation angle is given by the angle between the North
direction passing through the vector <span class="math notranslate nohighlight">\(\vec d\)</span> (i.e., along the
meridian of <span class="math notranslate nohighlight">\(\vec d\)</span>) and the vector <span class="math notranslate nohighlight">\(\vec p = R \hat
e_x\)</span>, where <span class="math notranslate nohighlight">\(R\)</span> is the same as above and <span class="math notranslate nohighlight">\(\hat e_x = (1,
0, 0)\)</span>, as shown in the following figure (note that <span class="math notranslate nohighlight">\(\hat e_x\)</span>
has been drawn twice because the one in the upper side represents
the orientation direction in the detector reference frame):</p>
<img alt="_images/orientation-direction.svg" src="_images/orientation-direction.svg" />
</li>
</ul>
<p>The purpose of the method <a class="reference internal" href="simulations.html#litebird_sim.simulations.Simulation.prepare_pointings" title="litebird_sim.simulations.Simulation.prepare_pointings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Simulation.prepare_pointings()</span></code></a>, used
in the example at the beginning of this chapter, is to combine the
quaternions that model the transformations between the many reference
frames used in the framework. The method
<a class="reference internal" href="observations.html#litebird_sim.observations.Observation.get_pointings" title="litebird_sim.observations.Observation.get_pointings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Observation.get_pointings()</span></code></a> uses these quaternions to compute
the actual pointing directions and the HWP angle on the fly.</p>
<p>To save memory,:meth:<cite>.Observation.get_pointings</cite> does <em>not</em> save the
pointings in a variable once it has calculated their value, and so
they must be recomputed every time you need them. However, in some
applications, pointings need to be accessed several times during a
simulation, and these repeated computations can introduce a noticeable
slowdown in the code.</p>
<p>If you want to trade speed with memory occupation, you can use the
function <a class="reference internal" href="#litebird_sim.pointings_in_obs.precompute_pointings" title="litebird_sim.pointings_in_obs.precompute_pointings"><code class="xref py py-func docutils literal notranslate"><span class="pre">precompute_pointings()</span></code></a> to compute all the pointings at
once and save them into every <a class="reference internal" href="observations.html#litebird_sim.observations.Observation" title="litebird_sim.observations.Observation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observation</span></code></a> objects. This
function fills the fields <cite>pointing_matrix</cite> and <cite>hwp_angle</cite>. The
datatype for the pointings is specified by <code class="docutils literal notranslate"><span class="pre">pointings_dtype</span></code>. This
can be done either with the low level functions</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">obs</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">create_observations</span><span class="p">(</span><span class="n">detectors</span><span class="o">=</span><span class="p">[</span><span class="n">det</span><span class="p">])</span>
<span class="n">lbs</span><span class="o">.</span><span class="n">prepare_pointings</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span><span class="n">sim</span><span class="o">.</span><span class="n">instrument</span><span class="p">,</span><span class="n">sim</span><span class="o">.</span><span class="n">spin2ecliptic_quats</span><span class="p">)</span>
<span class="n">lbs</span><span class="o">.</span><span class="n">precompute_pointings</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">pointings_dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
</pre></div>
</div>
<p>or with the methods of the <a class="reference internal" href="simulations.html#litebird_sim.simulations.Simulation" title="litebird_sim.simulations.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Simulation</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sim</span><span class="o">.</span><span class="n">create_observations</span><span class="p">(</span><span class="n">detectors</span><span class="o">=</span><span class="p">[</span><span class="n">det</span><span class="p">])</span>
<span class="n">sim</span><span class="o">.</span><span class="n">prepare_pointings</span><span class="p">()</span>
<span class="n">sim</span><span class="o">.</span><span class="n">precompute_pointings</span><span class="p">(</span><span class="n">pointings_dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="how-the-boresight-is-specified">
<h2>How the boresight is specified<a class="headerlink" href="#how-the-boresight-is-specified" title="Link to this heading">#</a></h2>
<p>As LiteBIRD includes three focal planes and two telescopes, the
specification of the boresight requires some care. In
<span id="id3">[<a class="reference internal" href="bibliography.html#id2" title="J. Delabrouille and The CORE collaboration. Exploring cosmic origins with CORE: Survey requirements and mission design. JCAP, 2018(4):014, April 2018. arXiv:1706.04516, doi:10.1088/1475-7516/2018/04/014.">3</a>]</span> and <span id="id4">[<a class="reference internal" href="bibliography.html#id3" title="Shaul Hanany and The PICO collaboration. PICO: Probe of Inflation and Cosmic Origins. arXiv e-prints, pages arXiv:1902.10541, February 2019. arXiv:1902.10541.">4</a>]</span>, the
boresight direction is encoded using just one number, the angle
between the boresight and the spin axis. However, both papers deal
with spacecrafts hosting only <em>one</em> focal plane.</p>
<p>The orientation of the boresight direction is specified using three
angles:</p>
<ol class="arabic simple">
<li><p>The ψ angle encodes the rotation of the focal plane with respect to
the boresight direction itself, and it is ideally 0°;</p></li>
<li><p>The angle between the boresight direction and the spin axis is
usually notated with the symbol β (among the three, this is the
most crucial number: it is 65° for CORE, 69° for PICO);</p></li>
<li><p>Finally, the boresight can be rotated by an angle φ around the spin
axis; this is important only when you have more than one focal
plane. For LiteBIRD, <span class="math notranslate nohighlight">\(\phi_\text{LFT} - \phi_\text{MHFT}
\approx 180^\circ\)</span>.</p></li>
</ol>
<iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/WbV_7nKXM1c"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen>
</iframe></section>
<section id="interpretation-of-pointings">
<h2>Interpretation of pointings<a class="headerlink" href="#interpretation-of-pointings" title="Link to this heading">#</a></h2>
<p>With «pointing», we refer to two different concepts:</p>
<ol class="arabic simple">
<li><p>The direction where the detector is looking at;</p></li>
<li><p>The orientation of the detector while looking at the sky.</p></li>
</ol>
<p>Theoretically, one can encode the direction as a one-length vector
<code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> or as a couple of angles. LBS adopts the second option
to save memory, and it encodes directions using the colatitude (i.e.,
90° minus the latitude) and the longitude, commonly indicated with the
letters θ (colatitude) and φ (longitude).</p>
<p>The orientation of the detector (second point above) can be expressed
either as a vector tangent to the sky sphere or as an angle calculated
with respect to the meridian/parallel going through the point the
detector is looking at. Again, to reduce memory usage, our framework
only encodes the angle.</p>
<p>The method <a class="reference internal" href="observations.html#litebird_sim.observations.Observation.get_pointings" title="litebird_sim.observations.Observation.get_pointings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Observation.get_pointings()</span></code></a> returns two matrices: a
“pointing matrix”, laid in memory as a <span class="math notranslate nohighlight">\((N, 3)\)</span> matrix, where
<span class="math notranslate nohighlight">\(N\)</span> is the number of samples in the timeline, and the last
dimension holds the colatitude, longitude, and orientation (in
radians). The second matrix contains the angle of the HWP. Let’s
visualize the position of these pointings on a Healpix map:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">healpy</span><span class="o">,</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pylab</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">nside</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">pixidx</span> <span class="o">=</span> <span class="n">healpy</span><span class="o">.</span><span class="n">ang2pix</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">pointings</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pointings</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">healpy</span><span class="o">.</span><span class="n">nside2npix</span><span class="p">(</span><span class="n">nside</span><span class="p">))</span>
<span class="n">m</span><span class="p">[</span><span class="n">pixidx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">healpy</span><span class="o">.</span><span class="n">mollview</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/scanning-strategy-example.png" src="_images/scanning-strategy-example.png" />
</section>
<section id="custom-scanning-strategies">
<h2>Custom scanning strategies<a class="headerlink" href="#custom-scanning-strategies" title="Link to this heading">#</a></h2>
<p>This section explains how LBS can model scanning strategies other than
the nominal «spinning» one. You will need to understand the functions
provided by the framework to deal with quaternions.</p>
<p>The framework uses a right-handed coordinate system, like the one
shown in figure:</p>
<img alt="_images/right-handed-coordinates.svg" src="_images/right-handed-coordinates.svg" />
<p>where the grey arrows indicate the verse of <em>positive</em> rotations.
(They follow the usual right-hand rule: point your thumb along the
axis and the other fingers will point towards the positive direction
of the rotation.)</p>
<section id="a-simple-scanning-strategy">
<h3>A simple scanning strategy<a class="headerlink" href="#a-simple-scanning-strategy" title="Link to this heading">#</a></h3>
<p>We are now ready to discuss implementing other types of scanning
strategies. There are plenty of reasons why one would like to go
beyond the class <a class="reference internal" href="#litebird_sim.scanning.SpinningScanningStrategy" title="litebird_sim.scanning.SpinningScanningStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinningScanningStrategy</span></code></a>:</p>
<ol class="arabic simple">
<li><p>You want to study the effect of non-idealities, like second-order
effects caused by contractions/dilations in the mechanical
structure of the telescope that make the angle between the spin
axis and the boresight vary with time.</p></li>
<li><p>You are thinking about how to make dedicated observations of some
celestial source (e.g., the Crab Nebula) to calibrate the
instruments.</p></li>
</ol>
<p>To define a new scanning strategy, we define a descendant of the
<a class="reference internal" href="#litebird_sim.scanning.ScanningStrategy" title="litebird_sim.scanning.ScanningStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScanningStrategy</span></code></a> class, an <a class="reference external" href="https://docs.python.org/3/library/abc.html">Abstract Base Class (ABC)</a>; the only mandatory
method is <a class="reference internal" href="#litebird_sim.scanning.ScanningStrategy.generate_spin2ecl_quaternions" title="litebird_sim.scanning.ScanningStrategy.generate_spin2ecl_quaternions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ScanningStrategy.generate_spin2ecl_quaternions()</span></code></a>,
which takes as inputs the start time, the length of the simulation,
and the time interval to be used between consecutive quaternions. The
method must return an instance of the <a class="reference internal" href="#litebird_sim.scanning.RotQuaternion" title="litebird_sim.scanning.RotQuaternion"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotQuaternion</span></code></a>,
containing the computed sequence of quaternions.</p>
<p>We will code here a straightforward scanning strategy, which does not
involve anything fancy: the spacecraft will spin around the Sun-Earth
axis, and the boresight direction will be along the same spin axis.
Thus, the boresight detector will see only the points along the
Ecliptic plane. This scanning strategy is scientifically useless, but
it is simple enough to be implemented in a few lines of code:</p>
<ol class="arabic simple">
<li><p>The transformation from boresight to the spin axis reference frame
is the identity;</p></li>
<li><p>There is no precession of the spin axis; therefore, the latter
stays on the Ecliptic axis;</p></li>
<li><p>The only rotation is caused by the revolution of the Sun-Earth axis
around the Sun, which is implemented as a rotation on the <cite>xy</cite>
plane, i.e., around the <cite>z</cite> axis.</p></li>
</ol>
<p>The following code implements our mock scanning strategy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">litebird_sim</span> <span class="k">as</span> <span class="nn">lbs</span>
<span class="kn">from</span> <span class="nn">litebird_sim</span> <span class="kn">import</span> <span class="n">RotQuaternion</span>
<span class="kn">import</span> <span class="nn">astropy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="k">class</span> <span class="nc">SimpleScanningStrategy</span><span class="p">(</span><span class="n">lbs</span><span class="o">.</span><span class="n">ScanningStrategy</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">generate_spin2ecl_quaternions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">astropy</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="p">],</span>
        <span class="n">time_span_s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">delta_time_s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RotQuaternion</span><span class="p">:</span>
        <span class="c1"># Compute how many quaternions are needed to cover</span>
        <span class="c1"># the time interval specified by &quot;time_span_s&quot;</span>
        <span class="n">num_of_quaternions</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">lbs</span><span class="o">.</span><span class="n">ScanningStrategy</span><span class="o">.</span><span class="n">optimal_num_of_quaternions</span><span class="p">(</span>
                <span class="n">time_span_s</span><span class="o">=</span><span class="n">time_span_s</span><span class="p">,</span>
                <span class="n">delta_time_s</span><span class="o">=</span><span class="n">delta_time_s</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Make room for the quaternions</span>
        <span class="n">spin2ecliptic_quats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_of_quaternions</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

        <span class="c1"># We compute the times when the quaternions need to be</span>
        <span class="c1"># calculated. Note that ScanningStrategy returns two</span>
        <span class="c1"># arrays (&quot;time&quot; and &quot;time_s&quot;), but we neglect the second</span>
        <span class="c1"># because we don&#39;t need it in this very simple case</span>
        <span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">ScanningStrategy</span><span class="o">.</span><span class="n">get_times</span><span class="p">(</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
            <span class="n">delta_time_s</span><span class="o">=</span><span class="n">delta_time_s</span><span class="p">,</span>
            <span class="n">num_of_quaternions</span><span class="o">=</span><span class="n">num_of_quaternions</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Compute the angle on the Ecliptic plane between the x</span>
        <span class="c1"># axis and the Sun-Earth axis, possibly using AstroPy</span>
        <span class="n">sun_earth_angles_rad</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">lbs</span><span class="o">.</span><span class="n">calculate_sun_earth_angles_rad</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># This code is *not* optimized: in a real-world case,</span>
        <span class="c1"># you&#39;ll probably want to use Numba instead of the</span>
        <span class="c1"># following &quot;for&quot; loop</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_of_quaternions</span><span class="p">):</span>
            <span class="c1"># Rotate by 90° around the y axis (move the boresight</span>
            <span class="c1"># to the Ecliptic xy plane)</span>
            <span class="n">spin2ecliptic_quats</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">quat_rotation_y</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Simulate the revolution of the spacecraft around</span>
            <span class="c1"># the Sun using the angles computed above</span>
            <span class="n">lbs</span><span class="o">.</span><span class="n">quat_left_multiply</span><span class="p">(</span>
                <span class="n">spin2ecliptic_quats</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                <span class="o">*</span><span class="n">lbs</span><span class="o">.</span><span class="n">quat_rotation_z</span><span class="p">(</span><span class="n">sun_earth_angles_rad</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
            <span class="p">)</span>

        <span class="c1"># Return the quaternions wrapped in an instance of</span>
        <span class="c1"># &quot;RotQuaternion&quot;</span>
        <span class="k">return</span> <span class="n">lbs</span><span class="o">.</span><span class="n">RotQuaternion</span><span class="p">(</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
            <span class="n">sampling_rate_hz</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">delta_time_s</span><span class="p">,</span>
            <span class="n">quats</span><span class="o">=</span><span class="n">spin2ecliptic_quats</span><span class="p">,</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>To test the class <code class="docutils literal notranslate"><span class="pre">SimpleScanningStrategy</span></code>, we write some code
similar to the example presented at the beginning of this section.
However, we cannot simulate for just one hour, as it would not be
enough to see any change in the pointing direction: the only thing
that changes as time passes is the position of the Earth on the
Ecliptic plane, and it takes 365 days to make one revolution.
Therefore, we extend the length of the simulation to 365 days. Of
course, there is no need to use a high sampling frequency in our
example, so we use here just one sample per day; for the same reason,
instead of computing one quaternion every minute, we compute one
quaternion every 30 days:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">astropy.units</span> <span class="k">as</span> <span class="nn">u</span>
<span class="kn">import</span> <span class="nn">healpy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">sim</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span>
    <span class="n">start_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">duration_s</span><span class="o">=</span><span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Simple simulation&quot;</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">12345</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_scanning_strategy</span><span class="p">(</span>
    <span class="n">scanning_strategy</span><span class="o">=</span><span class="n">SimpleScanningStrategy</span><span class="p">(),</span>
    <span class="n">delta_time_s</span><span class="o">=</span><span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
<span class="p">)</span>

<span class="n">det</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">DetectorInfo</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span>
    <span class="n">sampling_rate_hz</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
<span class="p">)</span>

<span class="p">(</span><span class="n">obs</span><span class="p">,)</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">create_observations</span><span class="p">(</span><span class="n">detectors</span><span class="o">=</span><span class="p">[</span><span class="n">det</span><span class="p">])</span>
<span class="n">lbs</span><span class="o">.</span><span class="n">prepare_pointings</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">lbs</span><span class="o">.</span><span class="n">InstrumentInfo</span><span class="p">(),</span> <span class="n">sim</span><span class="o">.</span><span class="n">spin2ecliptic_quats</span><span class="p">)</span>
<span class="n">pointings</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">get_pointings</span><span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">healpy</span><span class="o">.</span><span class="n">nside2npix</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
<span class="n">pixidx</span> <span class="o">=</span> <span class="n">healpy</span><span class="o">.</span><span class="n">ang2pix</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">pointings</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pointings</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">m</span><span class="p">[</span><span class="n">pixidx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">healpy</span><span class="o">.</span><span class="n">mollview</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is the result: we are indeed scanning the Ecliptic plane!</p>
<img alt="_images/simple-scanning-strategy.png" src="_images/simple-scanning-strategy.png" />
</section>
</section>
<section id="observing-point-sources-in-the-sky">
<h2>Observing point sources in the sky<a class="headerlink" href="#observing-point-sources-in-the-sky" title="Link to this heading">#</a></h2>
<p>It is helpful to simulate the observation of point sources in the sky,
both for a scientific purpose and for instrument calibration. For
instance, an essential task in the calibration of a CMB space
experiment is the estimation of the radiation pattern
<span class="math notranslate nohighlight">\(\gamma(\theta, \phi)\)</span> for each detector (sometimes
<span class="math notranslate nohighlight">\(\gamma\)</span> is called the <em>beam function</em>). One can do this task
through the observation of a bright point source, like one of the
outer planets (Mars, Jupiter, Saturn, etc.): assuming that the source
is pointlike and neglecting every other emission from the sky, the
response measured by a detector is proportional to the radiation
pattern <span class="math notranslate nohighlight">\(\gamma(\theta, \phi)\)</span>, where the angles <span class="math notranslate nohighlight">\(\theta,
\phi\)</span> identify the position of the planet <em>in the reference frame of
the detector</em>, i.e., where <span class="math notranslate nohighlight">\(\theta = 0\)</span> is the direction of the
main beam axis.</p>
<p>You can use the functions described in this chapter to analyze how
detectors will observe point sources in the sky, properly taking into
account proper motions of the sources (this applies to Solar System
objects, like planets and comets). The library provides the functions
<a class="reference internal" href="#litebird_sim.scanning.get_ecl2det_quaternions" title="litebird_sim.scanning.get_ecl2det_quaternions"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_ecl2det_quaternions()</span></code></a>, which has the same syntax as
<code class="xref py py-func docutils literal notranslate"><span class="pre">get_pointings()</span></code> but returns a matrix with shape <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">4)</span></code>
containing the <code class="docutils literal notranslate"><span class="pre">N</span></code> quaternions that transform from the Ecliptic
reference frame to the detector. Thus, you can use this method to
estimate how far from the main beam axis a celestial object is and its
orientation with respect to the orientation of the detector.</p>
<p>Here we show a simple example; the first part is identical to the
examples shown above (using the same scanning strategy as for CORE),
but here we employ AstroPy to compute the Ecliptic coordinates of
Jupiter during the simulation and convert them in the reference frame
of the boresight detector using <a class="reference internal" href="#litebird_sim.scanning.get_ecl2det_quaternions" title="litebird_sim.scanning.get_ecl2det_quaternions"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_ecl2det_quaternions()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">litebird_sim</span> <span class="k">as</span> <span class="nn">lbs</span>
<span class="kn">import</span> <span class="nn">astropy.time</span><span class="o">,</span> <span class="nn">astropy.units</span> <span class="k">as</span> <span class="nn">u</span>
<span class="kn">from</span> <span class="nn">astropy.coordinates</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ICRS</span><span class="p">,</span>
    <span class="n">get_body_barycentric</span><span class="p">,</span>
    <span class="n">BarycentricMeanEcliptic</span><span class="p">,</span>
    <span class="n">solar_system_ephemeris</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">sim</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span>
    <span class="c1"># We use AstroPy times here!</span>
    <span class="n">start_time</span><span class="o">=</span><span class="n">astropy</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="p">(</span><span class="s2">&quot;2020-01-01T00:00:00&quot;</span><span class="p">),</span>
    <span class="n">duration_s</span><span class="o">=</span><span class="mf">60.0</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Simple simulation&quot;</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">12345</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_scanning_strategy</span><span class="p">(</span>
    <span class="n">scanning_strategy</span><span class="o">=</span><span class="n">lbs</span><span class="o">.</span><span class="n">SpinningScanningStrategy</span><span class="p">(</span>
        <span class="n">spin_sun_angle_rad</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
        <span class="n">spin_rate_hz</span><span class="o">=</span><span class="mf">0.5</span> <span class="o">/</span> <span class="mf">60.0</span><span class="p">,</span>
        <span class="n">precession_rate_hz</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_instrument</span><span class="p">(</span>
    <span class="n">lbs</span><span class="o">.</span><span class="n">InstrumentInfo</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;core&quot;</span><span class="p">,</span>
        <span class="n">spin_boresight_angle_rad</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">65</span><span class="p">),</span>
    <span class="p">),</span>
<span class="p">)</span>

<span class="n">det</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">DetectorInfo</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">sampling_rate_hz</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">obs</span><span class="p">,</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">create_observations</span><span class="p">(</span><span class="n">detectors</span><span class="o">=</span><span class="p">[</span><span class="n">det</span><span class="p">])</span>

<span class="c1">#################################################################</span>
<span class="c1"># Here begins the juicy part</span>

<span class="n">solar_system_ephemeris</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;builtin&quot;</span><span class="p">)</span>

<span class="c1"># The variable &quot;icrs_pos&quot; contains the x,y,z coordinates of Jupiter</span>
<span class="c1"># in the ICRS reference frame for each sample time in the</span>
<span class="c1"># observation.</span>
<span class="n">icrs_pos</span> <span class="o">=</span> <span class="n">get_body_barycentric</span><span class="p">(</span>
    <span class="s2">&quot;jupiter&quot;</span><span class="p">,</span>
    <span class="n">obs</span><span class="o">.</span><span class="n">get_times</span><span class="p">(</span><span class="n">astropy_times</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
<span class="p">)</span>
<span class="c1"># Convert the ICRS r.f. into the barycentric mean Ecliptic r.f.,</span>
<span class="c1"># which is the reference frame used by the LiteBIRD simulation</span>
<span class="c1"># framework</span>
<span class="n">ecl_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">ICRS</span><span class="p">(</span><span class="n">icrs_pos</span><span class="p">)</span>
    <span class="o">.</span><span class="n">transform_to</span><span class="p">(</span><span class="n">BarycentricMeanEcliptic</span><span class="p">())</span>
    <span class="o">.</span><span class="n">cartesian</span>
    <span class="o">.</span><span class="n">get_xyz</span><span class="p">()</span>
    <span class="o">.</span><span class="n">value</span>
<span class="p">)</span>

<span class="c1"># The variable ecl_vec is a 3×N matrix containing the vectors.</span>
<span class="c1"># We normalize them so that each has length one (using the L_2</span>
<span class="c1"># norm, hence ord=2)</span>
<span class="n">ecl_vec</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ecl_vec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Convert the matrix to a N×3 shape</span>
<span class="n">ecl_vec</span> <span class="o">=</span> <span class="n">ecl_vec</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

<span class="c1"># Calculate the quaternions that convert the Ecliptic</span>
<span class="c1"># reference system into the detector reference system</span>
<span class="n">quats</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">get_ecl2det_quaternions</span><span class="p">(</span>
    <span class="n">obs</span><span class="p">,</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">spin2ecliptic_quats</span><span class="p">,</span>
    <span class="n">bore2spin_quat</span><span class="o">=</span><span class="n">sim</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">bore2spin_quat</span><span class="p">,</span>
    <span class="n">detector_quats</span><span class="o">=</span><span class="p">[</span><span class="n">det</span><span class="o">.</span><span class="n">quat</span><span class="p">],</span>
<span class="p">)</span>

<span class="c1"># Make room for the xyz vectors in the detector reference frame</span>
<span class="n">det_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">ecl_vec</span><span class="p">)</span>

<span class="c1"># Do the rotation!</span>
<span class="n">lbs</span><span class="o">.</span><span class="n">all_rotate_vectors</span><span class="p">(</span><span class="n">det_vec</span><span class="p">,</span> <span class="n">quats</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ecl_vec</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">det_vec</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[[ 0.57053937  0.07219102 -0.81809124]
 [ 0.57038372  0.06957116 -0.8184267 ]
 [ 0.57023386  0.0669494  -0.81874973]
 ...
 [ 0.99293109 -0.0800506   0.08763421]
 [ 0.99310516 -0.07743726  0.08800916]
 [ 0.99327345 -0.07482179  0.08837171]]
</pre></div>
</div>
<p>Again, the vectors printed by this script are in the <em>reference frame
of the detector</em>, where the vector <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">0</span> <span class="pre">1]</span></code> indicates the main axis
of the detector. We can inspect how close Jupiter moves to the main
beam axis during the simulation if we convert the set of <cite>(x, y, z)</cite>
vectors into the angles <span class="math notranslate nohighlight">\(\theta\)</span> (colatitude) and <span class="math notranslate nohighlight">\(\phi\)</span>
(longitude), as the colatitude is simply the angular distance from the
main beam axis (<span class="math notranslate nohighlight">\(\theta = 0\)</span>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">healpy</span>
<span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">healpy</span><span class="o">.</span><span class="n">vec2ang</span><span class="p">(</span><span class="n">det_vec</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">matplotlib.pylab</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">times</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">get_times</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span> <span class="o">-</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time [s]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Angular separation [deg]&quot;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/jupiter-angular-distance.svg" src="_images/jupiter-angular-distance.svg" />
<p>We see that Jupiter is ~10° away from the beam axis after ~30 seconds
since the start of the simulation.</p>
</section>
<section id="module-litebird_sim.scanning">
<span id="api-reference"></span><h2>API reference<a class="headerlink" href="#module-litebird_sim.scanning" title="Link to this heading">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="litebird_sim.scanning.RotQuaternion">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">litebird_sim.scanning.</span></span><span class="sig-name descname"><span class="pre">RotQuaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quats</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">_SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#litebird_sim.scanning.RotQuaternion" title="litebird_sim.scanning.RotQuaternion"><span class="pre">RotQuaternion</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Time</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_rate_hz</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.RotQuaternion" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A matrix of quaternions sampled uniformly over time that encode rotations</p>
<p>This class is used to hold quaternions that represent the
rotation from the reference frame of the LiteBIRD spin axis
to the Ecliptic reference frame. All the quaternions are normalized,
i.e., they encode a rotation in 3D space.</p>
<p>The class has the following members:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">quats</span></code> is a NumPy array of shape <code class="docutils literal notranslate"><span class="pre">(N</span> <span class="pre">×</span> <span class="pre">4)</span></code>, containing the
<code class="docutils literal notranslate"><span class="pre">N</span></code> (normalized) quaternions. All the quaternions are guaranteed
to be normalized.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">start_time</span></code> is either a floating-point number or an
<code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code> object. It can be <code class="docutils literal notranslate"><span class="pre">None</span></code> if and only
if there is just <em>one</em> quaternion in <code class="docutils literal notranslate"><span class="pre">quats</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sampling_rate_hz</span></code> is the sampling frequency of the
quaternions, in Hertz. It can be <code class="docutils literal notranslate"><span class="pre">None</span></code> if and only
if there is just <em>one</em> quaternion in <code class="docutils literal notranslate"><span class="pre">quats</span></code>.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="litebird_sim.scanning.RotQuaternion.conj">
<span class="sig-name descname"><span class="pre">conj</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.RotQuaternion.conj" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="litebird_sim.scanning.RotQuaternion.is_close_to">
<span class="sig-name descname"><span class="pre">is_close_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#litebird_sim.scanning.RotQuaternion" title="litebird_sim.scanning.RotQuaternion"><span class="pre">RotQuaternion</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#litebird_sim.scanning.RotQuaternion.is_close_to" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="litebird_sim.scanning.RotQuaternion.nbytes">
<span class="sig-name descname"><span class="pre">nbytes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.RotQuaternion.nbytes" title="Link to this definition">#</a></dt>
<dd><p>Return the number of bytes allocated for the quaternions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="litebird_sim.scanning.RotQuaternion.slerp">
<span class="sig-name descname"><span class="pre">slerp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_rate_hz</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsamples</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.RotQuaternion.slerp" title="Link to this definition">#</a></dt>
<dd><p>Oversample the quaternion using a “slerp” operation</p>
<p>This method combines the spin-axis-to-Ecliptic quaternions in
<code class="docutils literal notranslate"><span class="pre">self.quat</span></code> with two additional rotations (<cite>detector_quat</cite>,
<cite>bore2spin_quat</cite>), representing the transformation from the
reference frame of a detector to the boresight reference frame
and the transformation from the boresight to the spin
reference frame. The result is a quaternion that directly
transforms the reference frame of the detector to Ecliptic
coordinates.</p>
<p>Usually, the parameter <cite>detector_quat</cite> is read from the IMO,
and the parameter <cite>bore2spin_quat</cite> is calculated through the
class <a class="reference internal" href="detectors.html#litebird_sim.detectors.InstrumentInfo" title="litebird_sim.detectors.InstrumentInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstrumentInfo</span></code></a>, which has the field
<code class="docutils literal notranslate"><span class="pre">bore2spin_quat</span></code>. If all you have is the angle β (in
radians) between the boresight and the spin axis, just pass
<code class="docutils literal notranslate"><span class="pre">quat_rotation_y(β)</span></code> here.</p>
<p>As this kind of quaternion is used to compute the pointings of
a detector, which are used in map-making, it applies a «slerp»
operation on the quaternion, oversampling them to the sampling
frequency of the detector, expressed through the parameter
<cite>sampling_rate_hz</cite>.</p>
<p>The parameters <cite>time0</cite> and <cite>nsamples</cite> specify which is the
time interval that needs to be covered by the quaternions
computed by this method. The type of the parameter <cite>time0</cite>
must match that of <cite>self.start_time</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="litebird_sim.scanning.ScanningStrategy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">litebird_sim.scanning.</span></span><span class="sig-name descname"><span class="pre">ScanningStrategy</span></span><a class="headerlink" href="#litebird_sim.scanning.ScanningStrategy" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>A class that simulate a scanning strategy</p>
<p>This is an abstract base class; you should probably use
<a class="reference internal" href="#litebird_sim.scanning.SpinningScanningStrategy" title="litebird_sim.scanning.SpinningScanningStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinningScanningStrategy</span></code></a>, unless you are interested in
simulating other kinds of scanning strategies. If this is the
case, refer to the documentation.</p>
<dl class="py method">
<dt class="sig sig-object py" id="litebird_sim.scanning.ScanningStrategy.generate_spin2ecl_quaternions">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generate_spin2ecl_quaternions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_span_s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_time_s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#litebird_sim.scanning.RotQuaternion" title="litebird_sim.scanning.RotQuaternion"><span class="pre">RotQuaternion</span></a></span></span><a class="headerlink" href="#litebird_sim.scanning.ScanningStrategy.generate_spin2ecl_quaternions" title="Link to this definition">#</a></dt>
<dd><p>Generate the quaternions for spin-axis-to-Ecliptic rotations</p>
<p>This method simulates the scanning strategy of the spacecraft
assuming that the mission begins at some time <cite>start_time</cite> and
lasts for <cite>time_span_s</cite> seconds. The purpose of the function
is to compute the orientation of the spacecraft once every
<cite>delta_time_s</cite> seconds for the whole duration of the mission;
the orientation is expressed as a quaternion that encodes the
rotation from the reference frame of the spacecraft’s spin
axis (aligned with the y axis) to the reference frame of the
Ecliptic Coordinate System.</p>
<p>The function returns a <code class="xref py py-class docutils literal notranslate"><span class="pre">TimeDependentQuaternion</span></code>
object that fully covers the time interval between
<cite>start_time</cite> and <cite>start_time + time_span_s</cite>: this means that
an additional quaternion <em>after</em> the time <code class="docutils literal notranslate"><span class="pre">t_end</span> <span class="pre">=</span> <span class="pre">start_time</span>
<span class="pre">+</span> <span class="pre">time_span_s</span></code> might be appended.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_time</strong> (<em>Union</em><em>[</em><em>float</em><em>, </em><em>astropy.time.Time</em><em>]</em>) – start time
of the simulation. If it is a floating-point number,
it is arbitrary and can usually be set to 0.0;
otherwise, it must be a <code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code> object,
and in this case a more precise computation of the
orientation of the spacecraft is used. Depending on
the duration of the simulation, the second case can be
a few orders of magnitude slower: it should be used
only when the simulation needs to track the position
of moving objects (e.g., planets).</p></li>
<li><p><strong>time_span_s</strong> (<em>float</em>) – interval of time that needs to be
simulated, in seconds. These seconds are added to
<cite>start_time</cite>, and their meaning depends on its type:
if <cite>start_time</cite> is a float, you should consider the
duration as a sidereal time, but if it’s a
<cite>astropy.time.Time</cite> time, <cite>time_span_s</cite> is expressed
as a Solar time.</p></li>
<li><p><strong>delta_time_s</strong> (<em>float</em>) – for efficiency, quaternions are not
sampled at the same sample rate as the scientific
data, but at a much lower rate. The default should be
good for all the most common cases, but you can tune
it with this parameter.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="litebird_sim.scanning.ScanningStrategy.get_times">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_time_s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_of_quaternions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.ScanningStrategy.get_times" title="Link to this definition">#</a></dt>
<dd><p>Return a vector of equally-separated times</p>
<p>Depending on the type of the parameter <cite>start_time</cite> (either a
<code class="docutils literal notranslate"><span class="pre">float</span></code> or a <code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code> instance), return a
vector of times that mark the instant when a quaternion must
be computed by the class.</p>
<p>The class returns a 2-element tuple, containing (1) the time
expressed using the same type as <cite>start_time</cite> (either
<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code>), and (2) a vector
containing the time measured in seconds. The latter is useful
when your scanning strategy depends on the time for the
computation of angles and rotation, e.g., if you need to
compute <span class="math notranslate nohighlight">\(2\pi\nu t\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="litebird_sim.scanning.ScanningStrategy.optimal_num_of_quaternions">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">optimal_num_of_quaternions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_span_s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_time_s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#litebird_sim.scanning.ScanningStrategy.optimal_num_of_quaternions" title="Link to this definition">#</a></dt>
<dd><p>Return the number of quaternions to compute</p>
<p>Given a time span and a time interval between consecutive
quaternions, this static method computes how many quaternions
are needed to properly cover the time span.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="litebird_sim.scanning.SpinningScanningStrategy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">litebird_sim.scanning.</span></span><span class="sig-name descname"><span class="pre">SpinningScanningStrategy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spin_sun_angle_rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precession_rate_hz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_rate_hz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_time=&lt;Time</span> <span class="pre">object:</span> <span class="pre">scale='tdb'</span> <span class="pre">format='iso'</span> <span class="pre">value=2027-01-01</span> <span class="pre">00:00:00.000&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.SpinningScanningStrategy" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#litebird_sim.scanning.ScanningStrategy" title="litebird_sim.scanning.ScanningStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScanningStrategy</span></code></a></p>
<p>A class containing the parameters of the sky scanning strategy</p>
<p>This class is used to hold together the parameters that define the
nominal scanning strategy of the LiteBIRD spacecraft. It’s a
simple scanning strategy that closely matches the ones proposed
for other CMB experiments from space like CORE and Pico: a
spinning motion of the spacecraft around some axis, composed with
a precession motion around the Sun-Earth-spacecraft axis (assuming
that the spacecraft flies around the L_2 point of the Sun-Earth
system).</p>
<p>The constructor accepts the following parameters:</p>
<ul class="simple">
<li><p><cite>spin_sun_angle_rad</cite>: angle between the spin axis and the
Sun-LiteBIRD direction (floating-point number, in radians)</p></li>
<li><p><cite>precession_rate_hz</cite>: the period of the precession rotation
(floating-point number, in minutes)</p></li>
<li><p><cite>spin_rate_hz</cite>: the number of rotations per minute (RPM) around
the spin axis (floating-point number)</p></li>
<li><p><cite>start_time</cite>: an <code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code> object representing the
start of the observation. It’s currently unused, but it is meant
to represent the time when the rotation starts (i.e., the angle
ωt is zero).</p></li>
</ul>
<p>These fields are available once the object has been initialized.</p>
<p>You can create an instance of this class using the class method
<a class="reference internal" href="#litebird_sim.scanning.SpinningScanningStrategy.from_imo" title="litebird_sim.scanning.SpinningScanningStrategy.from_imo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_imo()</span></code></a>, which reads the
parameters from the IMO.</p>
<dl class="py method">
<dt class="sig sig-object py" id="litebird_sim.scanning.SpinningScanningStrategy.all_spin_to_ecliptic">
<span class="sig-name descname"><span class="pre">all_spin_to_ecliptic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sun_earth_angles_rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_vector_s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.SpinningScanningStrategy.all_spin_to_ecliptic" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="litebird_sim.scanning.SpinningScanningStrategy.from_imo">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_imo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="imo.html#litebird_sim.imo.Imo" title="litebird_sim.imo.imo.Imo"><span class="pre">Imo</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">url</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">UUID</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.SpinningScanningStrategy.from_imo" title="Link to this definition">#</a></dt>
<dd><p>Read the definition of the scanning strategy from the IMO</p>
<p>This function returns a <a class="reference internal" href="#litebird_sim.scanning.SpinningScanningStrategy" title="litebird_sim.scanning.SpinningScanningStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinningScanningStrategy</span></code></a>
object containing the set of parameters that define the
scanning strategy of the spacecraft, i.e., the way it observes
the sky during the nominal mission.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imo</strong> (<a class="reference internal" href="imo.html#litebird_sim.imo.Imo" title="litebird_sim.imo.Imo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imo</span></code></a>) – an instance of the <a class="reference internal" href="imo.html#litebird_sim.imo.Imo" title="litebird_sim.imo.Imo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imo</span></code></a> class</p></li>
<li><p><strong>url</strong> (str or <code class="docutils literal notranslate"><span class="pre">UUID</span></code>) – a reference to the data file
containing the definition of the scanning strategy. It can
be either a string like
<code class="docutils literal notranslate"><span class="pre">/releases/v1.0/satellite/scanning_parameters/</span></code> or a
UUID.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">imo</span> <span class="o">=</span> <span class="n">Imo</span><span class="p">()</span>
<span class="n">sstr</span> <span class="o">=</span> <span class="n">SpinningScanningStrategy</span><span class="o">.</span><span class="n">from_imo</span><span class="p">(</span>
    <span class="n">imo</span><span class="o">=</span><span class="n">imo</span><span class="p">,</span>
    <span class="n">url</span><span class="o">=</span><span class="s2">&quot;/releases/v1.0/satellite/scanning_parameters/&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sstr</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="litebird_sim.scanning.SpinningScanningStrategy.generate_spin2ecl_quaternions">
<span class="sig-name descname"><span class="pre">generate_spin2ecl_quaternions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_span_s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_time_s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#litebird_sim.scanning.RotQuaternion" title="litebird_sim.scanning.RotQuaternion"><span class="pre">RotQuaternion</span></a></span></span><a class="headerlink" href="#litebird_sim.scanning.SpinningScanningStrategy.generate_spin2ecl_quaternions" title="Link to this definition">#</a></dt>
<dd><p>Generate the quaternions for spin-axis-to-Ecliptic rotations</p>
<p>This method simulates the scanning strategy of the spacecraft
assuming that the mission begins at some time <cite>start_time</cite> and
lasts for <cite>time_span_s</cite> seconds. The purpose of the function
is to compute the orientation of the spacecraft once every
<cite>delta_time_s</cite> seconds for the whole duration of the mission;
the orientation is expressed as a quaternion that encodes the
rotation from the reference frame of the spacecraft’s spin
axis (aligned with the y axis) to the reference frame of the
Ecliptic Coordinate System.</p>
<p>The function returns a <code class="xref py py-class docutils literal notranslate"><span class="pre">TimeDependentQuaternion</span></code>
object that fully covers the time interval between
<cite>start_time</cite> and <cite>start_time + time_span_s</cite>: this means that
an additional quaternion <em>after</em> the time <code class="docutils literal notranslate"><span class="pre">t_end</span> <span class="pre">=</span> <span class="pre">start_time</span>
<span class="pre">+</span> <span class="pre">time_span_s</span></code> might be appended.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_time</strong> (<em>Union</em><em>[</em><em>float</em><em>, </em><em>astropy.time.Time</em><em>]</em>) – start time
of the simulation. If it is a floating-point number,
it is arbitrary and can usually be set to 0.0;
otherwise, it must be a <code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code> object,
and in this case a more precise computation of the
orientation of the spacecraft is used. Depending on
the duration of the simulation, the second case can be
a few orders of magnitude slower: it should be used
only when the simulation needs to track the position
of moving objects (e.g., planets).</p></li>
<li><p><strong>time_span_s</strong> (<em>float</em>) – interval of time that needs to be
simulated, in seconds. These seconds are added to
<cite>start_time</cite>, and their meaning depends on its type:
if <cite>start_time</cite> is a float, you should consider the
duration as a sidereal time, but if it’s a
<cite>astropy.time.Time</cite> time, <cite>time_span_s</cite> is expressed
as a Solar time.</p></li>
<li><p><strong>delta_time_s</strong> (<em>float</em>) – for efficiency, quaternions are not
sampled at the same sample rate as the scientific
data, but at a much lower rate. The default should be
good for all the most common cases, but you can tune
it with this parameter.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="litebird_sim.scanning.all_compute_pointing_and_orientation">
<span class="sig-prename descclassname"><span class="pre">litebird_sim.scanning.</span></span><span class="sig-name descname"><span class="pre">all_compute_pointing_and_orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quat_matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.all_compute_pointing_and_orientation" title="Link to this definition">#</a></dt>
<dd><p>Repeatedly apply <a class="reference internal" href="#litebird_sim.scanning.compute_pointing_and_orientation" title="litebird_sim.scanning.compute_pointing_and_orientation"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_pointing_and_orientation()</span></code></a></p>
<p>Prototype:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">all_compute_pointing_and_orientation</span><span class="p">(</span>
    <span class="n">result_matrix</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="n">quat_matrix</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Assuming that <cite>result_matrix</cite> is a (N, 3) matrix and <cite>quat_matrix</cite> a (N, 4)
matrix, iterate over all the N samples and apply
<a class="reference internal" href="#litebird_sim.scanning.compute_pointing_and_orientation" title="litebird_sim.scanning.compute_pointing_and_orientation"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_pointing_and_orientation()</span></code></a> to every item.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="litebird_sim.scanning.all_spin_to_ecliptic">
<span class="sig-prename descclassname"><span class="pre">litebird_sim.scanning.</span></span><span class="sig-name descname"><span class="pre">all_spin_to_ecliptic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sun_earth_angles_rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_sun_angle_rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precession_rate_hz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_rate_hz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_vector_s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.all_spin_to_ecliptic" title="Link to this definition">#</a></dt>
<dd><p>Apply <a class="reference internal" href="#litebird_sim.scanning.spin_to_ecliptic" title="litebird_sim.scanning.spin_to_ecliptic"><code class="xref py py-func docutils literal notranslate"><span class="pre">spin_to_ecliptic()</span></code></a> to each row of a matrix</p>
<p>Prototype:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">all_spin_to_ecliptic</span><span class="p">(</span>
    <span class="n">result_matrix</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
    <span class="n">sun_earth_angle_rad</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">spin_sun_angle_rad</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">precession_rate_hz</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">spin_rate_hz</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">time_vector_s</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">N</span><span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This function extends <a class="reference internal" href="#litebird_sim.scanning.spin_to_ecliptic" title="litebird_sim.scanning.spin_to_ecliptic"><code class="xref py py-func docutils literal notranslate"><span class="pre">spin_to_ecliptic()</span></code></a> to work with
the vector of times <cite>time_vector_s</cite>; all the other parameters must
still be float as in <cite>spin_to_ecliptic</cite>; the variable
<cite>result_matrix</cite> must be a matrix of shape <code class="docutils literal notranslate"><span class="pre">(len(time_vector_s),</span>
<span class="pre">4)</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="litebird_sim.scanning.calculate_sun_earth_angles_rad">
<span class="sig-prename descclassname"><span class="pre">litebird_sim.scanning.</span></span><span class="sig-name descname"><span class="pre">calculate_sun_earth_angles_rad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.calculate_sun_earth_angles_rad" title="Link to this definition">#</a></dt>
<dd><p>Compute the angle between the x axis and the Earth</p>
<p>This function computes the angle on the plane of the Ecliptic
(assuming to be the xy plane) between the Sun-Earth direction and
the x axis. Depending on the type of the parameter <cite>time_vector</cite>,
the result is computed differently:</p>
<ul class="simple">
<li><p>If <cite>time_vector</cite> is a <code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code> object, the angle is
computed using the Barycentric Mean Ecliptic reference frame and
the Ephemerides tables provided by AstroPy (slow but accurate)</p></li>
<li><p>Otherwise, <cite>time_vector</cite> is assumed to be a NumPy array of
floats, and a simple circular motion with constant angular
velocity is assumed. The angular velocity is
<code class="docutils literal notranslate"><span class="pre">YEARLY_OMEGA_SPIN_HZ</span></code>, which is equal to <span class="math notranslate nohighlight">\(2π/T\)</span>, with T
being the average duration of one year in seconds, and it is
assumed that at time <cite>t = 0</cite> the angle is zero.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="litebird_sim.scanning.compute_pointing_and_orientation">
<span class="sig-prename descclassname"><span class="pre">litebird_sim.scanning.</span></span><span class="sig-name descname"><span class="pre">compute_pointing_and_orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quaternion</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.compute_pointing_and_orientation" title="Link to this definition">#</a></dt>
<dd><p>Store in “result” the pointing direction and polarization angle.</p>
<p>Prototype:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">compute_pointing_and_orientation</span><span class="p">(</span>
    <span class="n">result</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
    <span class="n">quaternion</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The function assumes that <cite>quaternion</cite> encodes a rotation which
transforms the z axis into the direction of a beam in the sky,
i.e., it assumes that the beam points towards z in its own
reference frame and that <cite>quaternion</cite> transforms the reference
frame to celestial coordinates.</p>
<p>The variable <cite>result</cite> is used to save the result of the
computation, and it should be a 3-element NumPy array. On exit,
its values will be:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">result[0]</span></code>: the colatitude of the sky direction, in radians</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">result[1]</span></code>: the longitude of the sky direction, in radians</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">result[2]</span></code>: the orientation angle (assuming that in the beam
reference frame points towards x), measured with respect to the
North and East directions in the celestial sphere</p></li>
</ul>
<p>This function does <em>not</em> support broadcasting; use
<a class="reference internal" href="#litebird_sim.scanning.all_compute_pointing_and_orientation" title="litebird_sim.scanning.all_compute_pointing_and_orientation"><code class="xref py py-func docutils literal notranslate"><span class="pre">all_compute_pointing_and_orientation()</span></code></a> if you need to
transform several quaternions at once.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">compute_pointing_and_orientation</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="litebird_sim.scanning.get_det2ecl_quaternions">
<span class="sig-prename descclassname"><span class="pre">litebird_sim.scanning.</span></span><span class="sig-name descname"><span class="pre">get_det2ecl_quaternions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">observations,</span> <span class="pre">spin2ecliptic_quats:</span> <span class="pre">~litebird_sim.scanning.RotQuaternion,</span> <span class="pre">detector_quats:</span> <span class="pre">~typing.List[~litebird_sim.scanning.RotQuaternion],</span> <span class="pre">bore2spin_quat:</span> <span class="pre">~litebird_sim.scanning.RotQuaternion,</span> <span class="pre">quaternion_buffer=None,</span> <span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.get_det2ecl_quaternions" title="Link to this definition">#</a></dt>
<dd><p>Return the detector-to-Ecliptic quaternions</p>
<p>This function returns a <code class="docutils literal notranslate"><span class="pre">(D,</span> <span class="pre">N,</span> <span class="pre">4)</span></code> tensor containing the
quaternions that convert a vector in detector’s coordinates
into the frame of reference of the Ecliptic. The number of
quaternions is equal to the number of samples hold in this
observation, <code class="docutils literal notranslate"><span class="pre">observations.n_samples</span></code>.
Given that the z axis in the frame of reference of a detector
points along the main beam axis, this means that if you use
these quaternions to rotate the vector <cite>z = [0, 0, 1]</cite>, you
will end up with the sequence of vectors pointing towards the
points in the sky (in Ecliptic coordinates) that are observed
by the detector.
This is a low-level function; you should usually call the function
<code class="xref py py-func docutils literal notranslate"><span class="pre">get_pointings()</span></code>, which wraps this function to compute
both the pointing direction and the polarization angle.
See also the method <a class="reference internal" href="#litebird_sim.scanning.get_ecl2det_quaternions" title="litebird_sim.scanning.get_ecl2det_quaternions"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_ecl2det_quaternions()</span></code></a>, which
mirrors this one.
If you plan to call this function repeatedly, you can save
some running time by pre-allocating the buffer used to hold
the quaternions with the parameter <cite>quaternion_buffer</cite>. This
must be a NumPy floating-point array whose shape can be
computed using
<a class="reference internal" href="#litebird_sim.scanning.get_quaternion_buffer_shape" title="litebird_sim.scanning.get_quaternion_buffer_shape"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_quaternion_buffer_shape()</span></code></a>. If you pass
<cite>quaternion_buffer</cite>, the return value will be a pointer to
this buffer.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="litebird_sim.scanning.get_ecl2det_quaternions">
<span class="sig-prename descclassname"><span class="pre">litebird_sim.scanning.</span></span><span class="sig-name descname"><span class="pre">get_ecl2det_quaternions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin2ecliptic_quats:</span> <span class="pre">~litebird_sim.scanning.RotQuaternion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_quats:</span> <span class="pre">~litebird_sim.scanning.RotQuaternion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bore2spin_quat:</span> <span class="pre">~litebird_sim.scanning.RotQuaternion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quaternion_buffer=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.get_ecl2det_quaternions" title="Link to this definition">#</a></dt>
<dd><p>Return the Ecliptic-to-detector quaternions</p>
<p>This function returns a <code class="docutils literal notranslate"><span class="pre">(D,</span> <span class="pre">N,</span> <span class="pre">4)</span></code> matrix containing the <code class="docutils literal notranslate"><span class="pre">N</span></code>
quaternions of all the <code class="docutils literal notranslate"><span class="pre">D</span></code> detectors
that convert a vector in Ecliptic coordinates into
the frame of reference of the detector itself. The number of
quaternions is equal to the number of samples hold in this
observation.</p>
<p>This function is useful when you want to simulate how a point
source is observed by the detector’s beam: if you know the
Ecliptic coordinates of the point sources, you can easily
derive the location of the source with respect to the
reference frame of the detector’s beam.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="litebird_sim.scanning.get_quaternion_buffer_shape">
<span class="sig-prename descclassname"><span class="pre">litebird_sim.scanning.</span></span><span class="sig-name descname"><span class="pre">get_quaternion_buffer_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_of_detectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.get_quaternion_buffer_shape" title="Link to this definition">#</a></dt>
<dd><p>Return the shape of the buffer used to hold detector quaternions.</p>
<p>This function can be used to pre-allocate the buffer used by
<a class="reference internal" href="#litebird_sim.scanning.get_det2ecl_quaternions" title="litebird_sim.scanning.get_det2ecl_quaternions"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_det2ecl_quaternions()</span></code></a> and <a class="reference internal" href="#litebird_sim.scanning.get_ecl2det_quaternions" title="litebird_sim.scanning.get_ecl2det_quaternions"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_ecl2det_quaternions()</span></code></a> to
save the quaternions representing the change of the orientation of the
detectors with time.</p>
<p>Here is a typical use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">litebird_sim</span> <span class="k">as</span> <span class="nn">lbs</span>
<span class="n">observations</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">Observation</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">bufshape</span> <span class="o">=</span> <span class="n">get_quaternion_buffer_shape</span><span class="p">(</span><span class="n">observations</span><span class="p">,</span> <span class="n">n_detectors</span><span class="p">)</span>
<span class="n">quaternions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">bufshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">quats</span> <span class="o">=</span> <span class="n">get_det2ecl_quaternions</span><span class="p">(</span>
    <span class="o">...</span><span class="p">,</span>
    <span class="n">quaternion_buffer</span><span class="o">=</span><span class="n">quaternions</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="litebird_sim.scanning.orientation_angle">
<span class="sig-prename descclassname"><span class="pre">litebird_sim.scanning.</span></span><span class="sig-name descname"><span class="pre">orientation_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta_rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ordir</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.orientation_angle" title="Link to this definition">#</a></dt>
<dd><p>Compute the orientation of a detector at a given point on the sky</p>
<p>Prototype:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">orientation_angle</span><span class="p">(</span>
    <span class="n">theta_rad</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">phi_rad</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">ordir</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This function returns the orientation (in radians) with respect
to the North Pole of the celestial sphere for the point at
coordinates <cite>theta_rad</cite> (colatitude, in radians) and <cite>phi_rad</cite>
(longitude, in radians), assuming that <cite>ordir</cite> is a 3-element
NumPy array representing a normalized vector which departs from
the point on the celestial sphere and is aligned with the
orientation direction.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="litebird_sim.scanning.spin_to_ecliptic">
<span class="sig-prename descclassname"><span class="pre">litebird_sim.scanning.</span></span><span class="sig-name descname"><span class="pre">spin_to_ecliptic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sun_earth_angle_rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_sun_angle_rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precession_rate_hz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_rate_hz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.spin_to_ecliptic" title="Link to this definition">#</a></dt>
<dd><p>Compute a quaternion with the spin-axis-to-Ecliptic rotation</p>
<p>Prototype:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">spin_to_ecliptic</span><span class="p">(</span>
    <span class="n">result</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
    <span class="n">sun_earth_angle_rad</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">spin_sun_angle_rad</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">precession_rate_hz</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">spin_rate_hz</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">time_s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This function computes the (normalized) quaternion that encodes
the rotation which transforms the frame of reference of the
spacecraft’s spin axis into the Ecliptic frame of reference. The
result is saved in the parameter <cite>result</cite>, which must be a
4-element NumPy array; the order of the elements of the quaternion
is <cite>(vx, vy, vz, w)</cite>.</p>
<p>The function computes the quaternion as the following sequence of
rotations:</p>
<ol class="arabic simple">
<li><p>A rotation around the <cite>z</cite> axis by the angle <span class="math notranslate nohighlight">\(2π ν t\)</span>,
with <cite>ν</cite> being the parameter <cite>spin_rate_hz</cite> and <cite>t</cite> the
parameter <cite>time_s</cite> (this rotation accounts for the rotation of
the spacecraft around the spin axis)</p></li>
<li><p>A rotation around the <cite>y</cite> axis by the angle <span class="math notranslate nohighlight">\(π/2 -
\alpha\)</span>, with <cite>ɑ</cite> being the parameter <cite>spin_sun_angle_rad</cite>
(this accounts for the inclination of the spin axis with
respect to the Ecliptic plane)</p></li>
<li><p>A rotation around the <cite>x</cite> axis by the angle <span class="math notranslate nohighlight">\(2π ν t\)</span>,
with <cite>ν</cite> being the parameter <cite>precession_rate_hz</cite> and <cite>t</cite> the
parameter <cite>time_s</cite> (this rotation accounts for the rotation of
the spin axis because of the precessional motion)</p></li>
<li><p>A rotation around the <cite>z</cite> axis by the angle
<cite>sun_earth_angle_rad</cite> (this accounts for the yearly revolution
of the spacecraft around the Sun)</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sun_earth_angle_rad</strong> (<em>float</em>) – Angle between the x axis and the
Sun-Earth direction on the xy Ecliptic plane (in radians)</p></li>
<li><p><strong>spin_sun_angle_rad</strong> (<em>float</em>) – Angle between the spin axis of
the spacecraft and the Sun-Earth direction (in radians);
this angle is sometimes called <cite>ɑ</cite></p></li>
<li><p><strong>precession_rate_hz</strong> (<em>float</em>) – The frequency of rotations around
the precession axis (in rotations/sec)</p></li>
<li><p><strong>spin_rate_hz</strong> (<em>float</em>) – The frequency of rotations around the
spin axis (in rotations/sec)</p></li>
<li><p><strong>time_s</strong> (<em>float</em>) – the time when to compute the quaternion</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class" id="module-litebird_sim.pointings">
<dt class="sig sig-object py" id="litebird_sim.pointings.PointingProvider">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">litebird_sim.pointings.</span></span><span class="sig-name descname"><span class="pre">PointingProvider</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bore2ecliptic_quats</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#litebird_sim.scanning.RotQuaternion" title="litebird_sim.scanning.RotQuaternion"><span class="pre">RotQuaternion</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">hwp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hwp.html#litebird_sim.hwp.HWP" title="litebird_sim.hwp.HWP"><span class="pre">HWP</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.pointings.PointingProvider" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="litebird_sim.pointings.PointingProvider.get_pointings">
<span class="sig-name descname"><span class="pre">get_pointings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">detector_quat:</span> <span class="pre">~litebird_sim.scanning.RotQuaternion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_time:</span> <span class="pre">float</span> <span class="pre">|</span> <span class="pre">~astropy.time.core.Time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_time_global:</span> <span class="pre">float</span> <span class="pre">|</span> <span class="pre">~astropy.time.core.Time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_rate_hz:</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsamples:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pointing_buffer:</span> <span class="pre">~numpy.ndarray[~typing.Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">~numpy.dtype[~numpy._typing._array_like._ScalarType_co]]</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hwp_buffer:</span> <span class="pre">~numpy.ndarray[~typing.Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">~numpy.dtype[~numpy._typing._array_like._ScalarType_co]]</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pointings_dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">_ScalarType_co</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#litebird_sim.pointings.PointingProvider.get_pointings" title="Link to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>detector_quat</strong> – An instance of the class <a class="reference internal" href="#litebird_sim.scanning.RotQuaternion" title="litebird_sim.scanning.RotQuaternion"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotQuaternion</span></code></a></p></li>
<li><p><strong>start_time</strong> – The time of the first sample for which pointings are needed.
It can either be a floating-point number or a <code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code> object.</p></li>
<li><p><strong>start_time_global</strong> – The time of the first sample in the <em>simulation</em>.
It <em>must</em> be of the same type as <cite>start_time</cite>.</p></li>
<li><p><strong>sampling_rate_hz</strong> – The nominal sampling rate of the pointings</p></li>
<li><p><strong>nsamples</strong> – The number of pointings to compute for this detector</p></li>
<li><p><strong>pointing_buffer</strong> – A NumPy array with shape <code class="docutils literal notranslate"><span class="pre">(nsamples,</span> <span class="pre">3)</span></code> that will be
filled with the pointings (θ, φ, ψ) in radians. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a new NumPy
array will be allocated.</p></li>
<li><p><strong>hwp_buffer</strong> – A NumPy array with shape <code class="docutils literal notranslate"><span class="pre">(nsamples,)</span></code> that will be filled
with the angles of the HWP. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a new NumPy array will be allocated,
unless this <a class="reference internal" href="#litebird_sim.pointings.PointingProvider" title="litebird_sim.pointings.PointingProvider"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointingProvider</span></code></a> object has no HWP associated, i.e.,
the parameter <code class="docutils literal notranslate"><span class="pre">hwp</span></code> to the constructor <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> was set to <code class="docutils literal notranslate"><span class="pre">None</span></code>:
in this case, no buffer will be allocated.</p></li>
<li><p><strong>pointings_dtype</strong> – The type to use for the arrays <cite>pointing_buffer</cite> and
<cite>hwp_buffer</cite>, if they have not been provided. (If <cite>pointing_buffer</cite> and
<cite>hwp_buffer</cite> are not <code class="docutils literal notranslate"><span class="pre">None</span></code>, the original datatype will be kept unchanged.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A pair containing <cite>(pointing_buffer, hwp_buffer)</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="litebird_sim.pointings.PointingProvider.has_hwp">
<span class="sig-name descname"><span class="pre">has_hwp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.pointings.PointingProvider.has_hwp" title="Link to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if a HWP has been set.</p>
<p>If the function returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, you can access the field <cite>hwp</cite>, which
is an instance of one of the descendeants of class <a class="reference internal" href="hwp.html#litebird_sim.hwp.HWP" title="litebird_sim.hwp.HWP"><code class="xref py py-class docutils literal notranslate"><span class="pre">HWP</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="litebird_sim.pointings.apply_hwp_to_obs">
<span class="sig-prename descclassname"><span class="pre">litebird_sim.pointings.</span></span><span class="sig-name descname"><span class="pre">apply_hwp_to_obs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hwp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hwp.html#litebird_sim.hwp.HWP" title="litebird_sim.hwp.HWP"><span class="pre">HWP</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">pointing_matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.pointings.apply_hwp_to_obs" title="Link to this definition">#</a></dt>
<dd><p>Modify a pointing matrix to consider the effect of a HWP</p>
<p>This function modifies the variable <cite>pointing_matrix</cite> (a D×N×3 matrix,
with D the number of detectors and N the number of samples) so that the
orientation angle considers the behavior of the half-wave plate in
<cite>hwp</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="litebird_sim.pointings.get_hwp_angle">
<span class="sig-prename descclassname"><span class="pre">litebird_sim.pointings.</span></span><span class="sig-name descname"><span class="pre">get_hwp_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hwp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hwp.html#litebird_sim.hwp.HWP" title="litebird_sim.hwp.HWP"><span class="pre">HWP</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.pointings.get_hwp_angle" title="Link to this definition">#</a></dt>
<dd><p>Obtain the hwp angle for an observation</p>
</dd></dl>

<dl class="py function" id="module-litebird_sim.pointings_in_obs">
<dt class="sig sig-object py" id="litebird_sim.pointings_in_obs.precompute_pointings">
<span class="sig-prename descclassname"><span class="pre">litebird_sim.pointings_in_obs.</span></span><span class="sig-name descname"><span class="pre">precompute_pointings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">observations:</span> <span class="pre">~litebird_sim.observations.Observation</span> <span class="pre">|</span> <span class="pre">~typing.List[~litebird_sim.observations.Observation],</span> <span class="pre">pointings_dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#litebird_sim.pointings_in_obs.precompute_pointings" title="Link to this definition">#</a></dt>
<dd><p>Precompute all the pointings for a set of observations</p>
<p>Compute the full pointing matrix and the HWP angle for each <a class="reference internal" href="observations.html#litebird_sim.observations.Observation" title="litebird_sim.observations.Observation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observation</span></code></a>
object in <cite>obs_list</cite> and store them in the fields <code class="docutils literal notranslate"><span class="pre">pointing_matrix</span></code> and <code class="docutils literal notranslate"><span class="pre">hwp_angle</span></code>.
The datatype for the pointings is specified by <cite>pointings_dtype</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="litebird_sim.pointings_in_obs.prepare_pointings">
<span class="sig-prename descclassname"><span class="pre">litebird_sim.pointings_in_obs.</span></span><span class="sig-name descname"><span class="pre">prepare_pointings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="observations.html#litebird_sim.observations.Observation" title="litebird_sim.observations.Observation"><span class="pre">Observation</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="observations.html#litebird_sim.observations.Observation" title="litebird_sim.observations.Observation"><span class="pre">Observation</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instrument</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="detectors.html#litebird_sim.detectors.InstrumentInfo" title="litebird_sim.detectors.InstrumentInfo"><span class="pre">InstrumentInfo</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin2ecliptic_quats</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#litebird_sim.scanning.RotQuaternion" title="litebird_sim.scanning.RotQuaternion"><span class="pre">RotQuaternion</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">hwp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hwp.html#litebird_sim.hwp.HWP" title="litebird_sim.hwp.HWP"><span class="pre">HWP</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#litebird_sim.pointings_in_obs.prepare_pointings" title="Link to this definition">#</a></dt>
<dd><p>Store the quaternions needed to compute pointings into a list of <a class="reference internal" href="observations.html#litebird_sim.observations.Observation" title="litebird_sim.observations.Observation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observation</span></code></a> objects</p>
<p>This function computes the quaternions that convert the boresight direction
of <cite>instrument</cite> into the Ecliptic reference frame. The <cite>spin2ecliptic_quats</cite>
object must be an instance of the <a class="reference internal" href="#litebird_sim.scanning.RotQuaternion" title="litebird_sim.scanning.RotQuaternion"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotQuaternion</span></code></a> class and can
be created using the method <a class="reference internal" href="#litebird_sim.scanning.ScanningStrategy.generate_spin2ecl_quaternions" title="litebird_sim.scanning.ScanningStrategy.generate_spin2ecl_quaternions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ScanningStrategy.generate_spin2ecl_quaternions()</span></code></a>.</p>
</dd></dl>

</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="part3.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Basic simulation modules</p>
      </div>
    </a>
    <a class="right-next"
       href="quaternions.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Quaternions</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-motion-of-the-spacecraft">The motion of the spacecraft</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#computing-the-orientation-of-the-spacecraft">Computing the orientation of the spacecraft</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-quaternions-to-detector-pointings">From quaternions to detector pointings</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#how-the-boresight-is-specified">How the boresight is specified</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#interpretation-of-pointings">Interpretation of pointings</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#custom-scanning-strategies">Custom scanning strategies</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-simple-scanning-strategy">A simple scanning strategy</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#observing-point-sources-in-the-sky">Observing point sources in the sky</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-litebird_sim.scanning">API reference</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.RotQuaternion"><code class="docutils literal notranslate"><span class="pre">RotQuaternion</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.RotQuaternion.conj"><code class="docutils literal notranslate"><span class="pre">RotQuaternion.conj()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.RotQuaternion.is_close_to"><code class="docutils literal notranslate"><span class="pre">RotQuaternion.is_close_to()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.RotQuaternion.nbytes"><code class="docutils literal notranslate"><span class="pre">RotQuaternion.nbytes()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.RotQuaternion.slerp"><code class="docutils literal notranslate"><span class="pre">RotQuaternion.slerp()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.ScanningStrategy"><code class="docutils literal notranslate"><span class="pre">ScanningStrategy</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.ScanningStrategy.generate_spin2ecl_quaternions"><code class="docutils literal notranslate"><span class="pre">ScanningStrategy.generate_spin2ecl_quaternions()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.ScanningStrategy.get_times"><code class="docutils literal notranslate"><span class="pre">ScanningStrategy.get_times()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.ScanningStrategy.optimal_num_of_quaternions"><code class="docutils literal notranslate"><span class="pre">ScanningStrategy.optimal_num_of_quaternions()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.SpinningScanningStrategy"><code class="docutils literal notranslate"><span class="pre">SpinningScanningStrategy</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.SpinningScanningStrategy.all_spin_to_ecliptic"><code class="docutils literal notranslate"><span class="pre">SpinningScanningStrategy.all_spin_to_ecliptic()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.SpinningScanningStrategy.from_imo"><code class="docutils literal notranslate"><span class="pre">SpinningScanningStrategy.from_imo()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.SpinningScanningStrategy.generate_spin2ecl_quaternions"><code class="docutils literal notranslate"><span class="pre">SpinningScanningStrategy.generate_spin2ecl_quaternions()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.all_compute_pointing_and_orientation"><code class="docutils literal notranslate"><span class="pre">all_compute_pointing_and_orientation()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.all_spin_to_ecliptic"><code class="docutils literal notranslate"><span class="pre">all_spin_to_ecliptic()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.calculate_sun_earth_angles_rad"><code class="docutils literal notranslate"><span class="pre">calculate_sun_earth_angles_rad()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.compute_pointing_and_orientation"><code class="docutils literal notranslate"><span class="pre">compute_pointing_and_orientation()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.get_det2ecl_quaternions"><code class="docutils literal notranslate"><span class="pre">get_det2ecl_quaternions()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.get_ecl2det_quaternions"><code class="docutils literal notranslate"><span class="pre">get_ecl2det_quaternions()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.get_quaternion_buffer_shape"><code class="docutils literal notranslate"><span class="pre">get_quaternion_buffer_shape()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.orientation_angle"><code class="docutils literal notranslate"><span class="pre">orientation_angle()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.scanning.spin_to_ecliptic"><code class="docutils literal notranslate"><span class="pre">spin_to_ecliptic()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.pointings.PointingProvider"><code class="docutils literal notranslate"><span class="pre">PointingProvider</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.pointings.PointingProvider.get_pointings"><code class="docutils literal notranslate"><span class="pre">PointingProvider.get_pointings()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.pointings.PointingProvider.has_hwp"><code class="docutils literal notranslate"><span class="pre">PointingProvider.has_hwp()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.pointings.apply_hwp_to_obs"><code class="docutils literal notranslate"><span class="pre">apply_hwp_to_obs()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.pointings.get_hwp_angle"><code class="docutils literal notranslate"><span class="pre">get_hwp_angle()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.pointings_in_obs.precompute_pointings"><code class="docutils literal notranslate"><span class="pre">precompute_pointings()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#litebird_sim.pointings_in_obs.prepare_pointings"><code class="docutils literal notranslate"><span class="pre">prepare_pointings()</span></code></a></li>
</ul>
</li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">

  <div class="tocsection sourcelink">
    <a href="_sources/scanning.rst.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2020, The LiteBIRD Simulation Team.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.0.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>