
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Scanning strategy &#8212; LiteBIRD simulation pipeline 0.1.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The Instrument Model Database (IMO)" href="imo.html" />
    <link rel="prev" title="Observations" href="observations.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="scanning-strategy">
<h1>Scanning strategy<a class="headerlink" href="#scanning-strategy" title="Permalink to this headline">¶</a></h1>
<p>The LiteBIRD Simulation Framework provides a set of tools to simulate
the orbit of the spacecraft and to compute the directions where each
detector is looking at the sky as a function of time (this is usually
called <em>pointing information</em>, and we’ll consistently use this jargon
in the documentation). This chapter provides an in-depth explanation
about how the use the facilities provided by the framework.</p>
<div class="section" id="the-spacecraft-s-motion">
<h2>The spacecraft’s motion<a class="headerlink" href="#the-spacecraft-s-motion" title="Permalink to this headline">¶</a></h2>
<p>In the case of a space mission like LiteBIRD, the motion of the
spacecraft decides where each detector is looking at each time. The
following video shows qualitatively which kind of motion is simulated
by our framework:</p>
<iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/C0xdvI1rNzg"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen>
</iframe><p>(The animation was created using <a class="reference external" href="http://povray.org/">POV-Ray</a>, and
the files used to create it are available on <a class="reference external" href="https://github.com/ziotom78/povray_scanning_strategy">GitHub</a> .)</p>
<p>You can see that there are <em>two</em> rotations in the animation: the
spacecraft spins quickly around its spin axis (grey axis), but this
axis does not stand still: it performs a precession around the blue
axis, which represents the Sun-Earth direction. (You should imagine
the Earth on the left, and the Sun on the very far left.)</p>
<p>Note that the detectors are not necessarily aligned with the spin
axis; in fact, the animation shows the actual direction of observation
for two different detectors, in red and green: you can see that they
are looking quite at two opposite sides of the spin axis. Every
detector looks along its own direction, but detectors belonging to the
same instrument (e.g., LFT) look not far away from each other; it is
customary to express their pointing directions relative to an
«average» direction, called the <em>boresight direction</em>, which is the
main optical axis of the instrument. Since in LiteBIRD there are <em>two</em>
instruments, LFT and MHFT, there are two boresight directions. This is
the true meaning of the red and green axes in the video above: the red
axis represents the «average» direction where LFT detectors are
looking at, and the green axis is the same for MHFT.</p>
<p>The animation does not show a <em>third</em> rotation happening, which is the
revolution of the spacecraft around the Sun, taking one year to
complete. (Including it in the video would have been useless, as it is
<em>really</em> slow!). This means that the motion of the spacecraft is the
composition of <em>three</em> rotations:</p>
<ol class="arabic simple">
<li><p>Rotation of the spacecraft around the spin axis (grey line);</p></li>
<li><p>Rotation (precession) of the spin axis around the Sun-Earth axis
(blue line);</p></li>
<li><p>Yearly rotation of the Sun-Earth axis around the Sun.</p></li>
</ol>
<p>If you think about it, you will realize that the kinematics of this
motion can be fully described by the following quantities:</p>
<ul class="simple">
<li><p>The angle between the spin axis and the boresight direction(s),
usually called β;</p></li>
<li><p>The angle between the spin axis and the Sun-Earth axis, usually
called α.</p></li>
<li><p>The speed of the rotation of the boresight direction around the spin
axis;</p></li>
<li><p>The speed of the precession around the Sun-Earth axis, which is
usually slower than the rotation speed;</p></li>
</ul>
<p>They are sketched in the following diagram:</p>
<img alt="_images/litebird-scanning-strategy.svg" src="_images/litebird-scanning-strategy.svg" /><p>These parameters define the so-called <em>scanning strategy</em>, i.e., the
way the instruments observe the sky during the mission’s lifetime. The
LiteBIRD Simulation Framework provides all the tools necessary to
simulate the composition of these rotations, and it can produce
pointing information from the synthetic description of the scanning
strategy. Here is a full example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">litebird_sim</span> <span class="k">as</span> <span class="nn">lbs</span>
<span class="kn">import</span> <span class="nn">astropy.units</span> <span class="k">as</span> <span class="nn">u</span>

<span class="n">sim</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span>
    <span class="n">start_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">duration_s</span><span class="o">=</span><span class="mf">60.0</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Sample simulation&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># We now simulate the motion of the spacecraft over a time span</span>
<span class="c1"># of one minute (specified in the `duration_s` parameter above).</span>
<span class="c1"># We use the scanning strategy proposed for CORE, which is</span>
<span class="c1"># qualitatively similar to LiteBIRD&#39;s (Delabrouille et al., 2018,</span>
<span class="c1"># https://doi.org/10.1088/1475-7516/2018/04/014</span>
<span class="n">sim</span><span class="o">.</span><span class="n">generate_bore2ecl_quaternions</span><span class="p">(</span>
    <span class="n">scanning_strategy</span><span class="o">=</span><span class="n">lbs</span><span class="o">.</span><span class="n">SpinningScanningStrategy</span><span class="p">(</span>
        <span class="n">spin_sun_angle_deg</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
        <span class="n">spin_boresight_angle_deg</span><span class="o">=</span><span class="mi">65</span><span class="p">,</span>
        <span class="n">spin_rate_rpm</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="c1"># We use astropy to convert the period (4 days) in</span>
        <span class="c1"># minutes, the unit expected for the precession period</span>
        <span class="n">precession_period_min</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="c1"># The motion of the spacecraft is now encoded in a set of quaternions,</span>
<span class="c1"># in the field `sim.bore2ecliptic_quats`. We use it to produce the</span>
<span class="c1"># pointing information for a fake boresight detector `det`.</span>
<span class="n">det</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">Detector</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">sampling_rate_hz</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">obs</span><span class="p">,</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">create_observations</span><span class="p">(</span><span class="n">detectors</span><span class="o">=</span><span class="p">[</span><span class="n">det</span><span class="p">])</span>
<span class="n">pointings</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">get_pointings</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">bore2ecliptic_quats</span><span class="p">,</span> <span class="n">det</span><span class="o">.</span><span class="n">quat</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape:&quot;</span><span class="p">,</span> <span class="n">pointings</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Pointings:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pointings</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Shape: (600, 3)
Pointings:
[[ 2.18166156  0.         -1.57079633]
 [ 2.18164984 -0.00579129 -1.57633021]
 [ 2.18161186 -0.01158231 -1.58186382]
 ...
 [ 0.08854811 -2.96748668 -1.73767999]
 [ 0.08788054 -3.0208052  -1.68678085]
 [ 0.08745441 -3.07477554 -1.63522983]]
</pre></div>
</div>
<p>All the details in this code are explained in the next sections, so
for now just keep in mind the overall shape of the code:</p>
<ol class="arabic simple">
<li><p>Once the duration of the simulation (one hour in the example
above), we call the method
<a class="reference internal" href="simulations.html#litebird_sim.simulations.Simulation.generate_bore2ecl_quaternions" title="litebird_sim.simulations.Simulation.generate_bore2ecl_quaternions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Simulation.generate_bore2ecl_quaternions()</span></code></a>, which forces the
framework to compute how the orientation of the spacecraft with
respect to the sky sphere evolves with time. This method produces a
set of <a class="reference external" href="https://en.wikipedia.org/wiki/Quaternion">quaternions</a>,
which encode the result of the composition of all the rotations
described above; these quaternions are saved in the
<code class="docutils literal notranslate"><span class="pre">bore2ecliptic_quats</span></code> field of the <code class="docutils literal notranslate"><span class="pre">sim</span></code> class.</p></li>
<li><p>When the simulation code needs to determine where a detector is
pointing to (the detector <code class="docutils literal notranslate"><span class="pre">det</span></code> in our example), the quaternions
are used to retrieve the coordinates on the Sky sphere and the
polarization angle, both computed in the Ecliptic reference frame
with the sampling rate of the detector, which in our example is 10
Hz (i.e., ten samples per second). In the example above, this is
done by the method <a class="reference internal" href="observations.html#litebird_sim.observations.Observation.get_pointings" title="litebird_sim.observations.Observation.get_pointings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Observation.get_pointings()</span></code></a>.</p></li>
<li><p>There is an ambiguity in our definition of «boresight»: are we
using the boresight direction of LFT or MHFT? The answer is: it
depends! The two boresight direction are actually the same but with
a phase π in the angle with respect to the spin axis, so that if
the boresight for LFT at time <span class="math notranslate nohighlight">\(t\)</span> is at an angle
<span class="math notranslate nohighlight">\(\theta_\mathrm{LFT}(t) = 2\pi\nu t\)</span>, the boresight for MHFT
is <span class="math notranslate nohighlight">\(\theta_\mathrm{MHFT}(t) = 2\pi\nu t + \pi\)</span>. Using one
boresight or another is the same as introducing a phase delay in
the spinning, which is usually harmless unless you are simulating
the acquisition of detectors from both instruments.</p></li>
</ol>
</div>
<div class="section" id="computing-the-spacecraft-s-orientation">
<h2>Computing the spacecraft’s orientation<a class="headerlink" href="#computing-the-spacecraft-s-orientation" title="Permalink to this headline">¶</a></h2>
<p>To compute where a detector is looking at the sky sphere, there is a
number of transformation that need to be carried out:</p>
<img alt="_images/coordinate-systems.svg" src="_images/coordinate-systems.svg" /><p>We start from the detector’s reference frame, which assumes that the
main beam of the radiation pattern is aligned with the <cite>z</cite> axis, and
that the detector is sensitive to the polarization along the <cite>x</cite> axis.</p>
<p>The next reference frame is the <em>boresight</em>, and to convert from the
detector’s reference frame to the boresight there is a rotation, which
is encoded in a quaternion that is saved in the IMO.</p>
<p>Next, we move from the reference frame of the boresight to that of the
spacecraft. In this case, the spin axis is supposed to be aligned with
the positive <cite>z</cite> direction; the transformation from the boresight is
encoded through the parameter <code class="docutils literal notranslate"><span class="pre">spin_boresight_angle_deg</span></code> passed to
the constructor of <code class="xref py py-class docutils literal notranslate"><span class="pre">SpinningScanningstrategy</span></code>.</p>
<p>The next transformation goes from the spacecraft’s to the Ecliptic
reference frame; the Ecliptic is on the <cite>xy</cite> plane, and the <cite>z</cite> axis
points towards the Ecliptic North Pole. In this case, the framework
provides two ways to compute the transformation:</p>
<ol class="arabic">
<li><p>The revolution of the Earth around the Sun is modelled using a
plain circular motion, and the starting position is arbitrary; this
mode is triggered whenever the time is tracked using floating-point
numbers (i.e., the parameter <cite>start_time</cite> in the constructor of
<a class="reference internal" href="simulations.html#litebird_sim.simulations.Simulation" title="litebird_sim.simulations.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Simulation</span></code></a> is a <code class="docutils literal notranslate"><span class="pre">float</span></code>).</p></li>
<li><p>The proper motion of the Earth around the Sun is computed using
ephemeridis tables; the calculation is much slower, but the result
enables to properly simulate the observation of moving objects in
the Solar System, like planets or asteroids. In this case, the
parameter <cite>start_time</cite> must be an instance of the class
<code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code>. In the example above, we would enable the
computation of proper Earth’s motion with the following small
change:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">astropy.time</span>

<span class="n">sim</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span>
    <span class="c1"># Turn on full computation of the Earth&#39;s orbit around the Sun</span>
    <span class="n">start_time</span><span class="o">=</span><span class="n">astropy</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="p">(</span><span class="s2">&quot;2020-01-01&quot;</span><span class="p">),</span>
    <span class="n">duration_s</span><span class="o">=</span><span class="mf">60.0</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Sample simulation&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
<div class="section" id="from-quaternions-to-detector-pointings">
<h3>From quaternions to detector pointings<a class="headerlink" href="#from-quaternions-to-detector-pointings" title="Permalink to this headline">¶</a></h3>
<p>To compute the pointing information for a detector, the quaternions
computed through the call to
<a class="reference internal" href="simulations.html#litebird_sim.simulations.Simulation.generate_bore2ecl_quaternions" title="litebird_sim.simulations.Simulation.generate_bore2ecl_quaternions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Simulation.generate_bore2ecl_quaternions()</span></code></a> are not enough, as
they only tell how to convert a vector from the <em>boresight</em> reference
frame to the Ecliptic reference frame. We need another quaternion that
tells how to convert from the reference frame of the detector to that
of the boresight. This information is included in the IMO and is
properly initialized if you call <code class="xref py py-meth docutils literal notranslate"><span class="pre">Detector.from_imo()</span></code>. If you do
not specify any quaternion, the constructor for <code class="xref py py-class docutils literal notranslate"><span class="pre">Detector</span></code>
will assume that the detector is looking at the boresight, and it will
thus use the quaternion <span class="math notranslate nohighlight">\((0 0 0 1)\)</span>; this is the case of the
simple example we presented above.</p>
<p>The LiteBIRD Simulation Framework recomputes the orientation of the
spacecraft with a regular spacing in time (the default is one minute).
However, pointings need to be known at the same sampling frequency
used by the detector, which is usually much higher than the frequency
used to compute the quaternions (in our example above, the sampling
frequency of detector <code class="docutils literal notranslate"><span class="pre">det</span></code> was 10 Hz, but the sampling frequency of
the quaternions was 1/60 Hz). Since the framework uses quaternions to
encode the orientation of the spacecraft, oversampling them to the
sampling frequency of the detector is just a matter of applying a
spherical linear interpolation (abbr. <a class="reference external" href="https://en.wikipedia.org/wiki/Slerp">slerp</a>), according to the following
figure:</p>
<img alt="_images/quaternion-sampling.svg" src="_images/quaternion-sampling.svg" /><p>To be sure to include an additional quaternion <em>after</em> the last
sample, like in the figure above, the framework provides the static
method <code class="xref py py-meth docutils literal notranslate"><span class="pre">ScanningStrategy.optimal_num_of_quaternions()</span></code>, which
computes how many quaternions need to be calculated to cover some time
span with a given interval between quaternions. For instance, if our
simulation lasts 100 s and we want one quaternion every minute, then
the expected number of quaternions to be computed is 3: one at
<span class="math notranslate nohighlight">\(t = 0\)</span>, one at <span class="math notranslate nohighlight">\(t = 60\,\mathrm{s}\)</span>, and one at <span class="math notranslate nohighlight">\(t
= 120\,\mathrm{s}\)</span>, so that the latter two can be interpolated for the
samples in the range <span class="math notranslate nohighlight">\(60\,\mathrm{s} \leq t \leq
100\,\mathrm{s}\)</span>. Here is how the function works:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">lbs</span><span class="o">.</span><span class="n">ScanningStrategy</span><span class="o">.</span><span class="n">optimal_num_of_quaternions</span><span class="p">(</span>
    <span class="n">time_span_s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">delta_time_s</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span>
<span class="p">))</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
<p>When using MPI, the relatively small size in memory of the quaternions
(the thick black lines in the figure) enables the framework to keep
the a duplicate of the list in all the MPI processes. This is unlike
what happens with the data in TODs (the thin gray lines), which are
split in several instances of the <a class="reference internal" href="observations.html#litebird_sim.observations.Observation" title="litebird_sim.observations.Observation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observation</span></code></a> class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Slerp assumes a rotation with constant angular speed between
consecutive quaternions, and thus it only approximates the true
composition of all the rotations (spin, precession, revolution
around the Sun) that we have discussed above. However, don’t forget
that the <em>real</em> spacecraft will follow a scanning strategy that
will be more complex than the one described by our geometrical
model, because of many non-idealities that are unavoidable in a
spacecraft. The approximation of the «slerp» operation is thus
unlikely to be relevant.</p>
</div>
<p>Once all the quaternions have been computed at the proper sampling
rate, the direction of the detector on the sky and its polarization
angle are computed as follows:</p>
<ul class="simple">
<li><p>The direction is simply the vector <span class="math notranslate nohighlight">\(\vec d = R \hat e_z\)</span>,
where <span class="math notranslate nohighlight">\(R\)</span> is the overall rotation from the detector’s
reference frame to the Ecliptic reference frame, and <span class="math notranslate nohighlight">\(\hat e_z
= (0, 0, 1)\)</span> is the one-length vector aligned with the <cite>z</cite> axis.</p></li>
<li><p>The polarization angle is given by the angle between the North
direction passing through the vector <span class="math notranslate nohighlight">\(\vec d\)</span> (i.e., along the
parallel of <span class="math notranslate nohighlight">\(\vec d\)</span>) and the vector <span class="math notranslate nohighlight">\(\vec p = R \hat
e_x\)</span>, where <span class="math notranslate nohighlight">\(R\)</span> is the same as above and <span class="math notranslate nohighlight">\(\hat e_x = (1,
0, 0)\)</span>, as shown in the following figure:</p></li>
</ul>
<img alt="_images/polarization-direction.svg" src="_images/polarization-direction.svg" /></div>
</div>
<div class="section" id="interpretation-of-pointings">
<h2>Interpretation of pointings<a class="headerlink" href="#interpretation-of-pointings" title="Permalink to this headline">¶</a></h2>
<p>We saw in the example above that the pointings for detector <code class="docutils literal notranslate"><span class="pre">det</span></code>
were saved in a matrix of shape <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">×</span> <span class="pre">3</span></code>, but the meaning of those
numbers are probably unclear. With «pointing», we refer to two
different concept:</p>
<ol class="arabic simple">
<li><p>The direction where the detector is looking at;</p></li>
<li><p>The orientation of the detector while it’s looking at the sky.</p></li>
</ol>
<p>The direction can be encoded either as a one-length vector <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y,</span>
<span class="pre">z)</span></code> or as a couple of angles; the LiteBIRD simulation framework
adopts the second option to save memory, and it encodes directions
using the colatitude (i.e., 90° minus the latitude) and the longitude,
commonly indicated with the letters θ (colatitude) and φ (longitude).</p>
<p>The orientation of the detector (second point above) can be expressed
either as a vector that is tangent to the sky sphere, or as an angle
calculated with respect to the meridian/parallel going through the
point the detector is looking at. Again, to reduce memory usage, our
framework only encodes the angle.</p>
<p>Thus, the method <a class="reference internal" href="observations.html#litebird_sim.observations.Observation.get_pointings" title="litebird_sim.observations.Observation.get_pointings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Observation.get_pointings()</span></code></a> returns a N×3
matrix whose columns contain the colatitude (in radians), longitude
(ditto), and polarization angle with respect to the North and South
poles of the sky. Let’s visualize the position of these pointings on a
Healpix map:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">healpy</span><span class="o">,</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pylab</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">nside</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">pixidx</span> <span class="o">=</span> <span class="n">healpy</span><span class="o">.</span><span class="n">ang2pix</span><span class="p">(</span><span class="n">nside</span><span class="p">,</span> <span class="n">pointings</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pointings</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">healpy</span><span class="o">.</span><span class="n">nside2npix</span><span class="p">(</span><span class="n">nside</span><span class="p">))</span>
<span class="n">m</span><span class="p">[</span><span class="n">pixidx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">healpy</span><span class="o">.</span><span class="n">mollview</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/scanning-strategy-example.png" src="_images/scanning-strategy-example.png" />
</div>
<div class="section" id="custom-scanning-strategies">
<h2>Custom scanning strategies<a class="headerlink" href="#custom-scanning-strategies" title="Permalink to this headline">¶</a></h2>
<p>In this section we explain how scanning strategies different from the
nominal, «spinning» strategy can be modelled. You will need to
understand the functions provided by the framework to deal with
quaternions.</p>
<p>The framework uses a right-handed coordinate system, like the one
shown in figure:</p>
<img alt="_images/right-handed-coordinates.svg" src="_images/right-handed-coordinates.svg" /><p>where the grey arrows indicate the verse of <em>positive</em> rotations (they
follow the usual right-hand rule: point your thumb along the axis, and
the other fingers will point towards the positive direction of the
rotation).</p>
<div class="section" id="a-few-words-about-quaternions">
<h3>A few words about quaternions<a class="headerlink" href="#a-few-words-about-quaternions" title="Permalink to this headline">¶</a></h3>
<p>To describe a rotation in 3D space, there are several choices: <a class="reference external" href="https://en.wikipedia.org/wiki/Euler_angles">Euler
angles</a>, <a class="reference external" href="https://en.wikipedia.org/wiki/Rotation_matrix">rotation
matrices</a>,
<a class="reference external" href="https://en.wikipedia.org/wiki/Quaternion">quaternions</a>, etc. Each
of these systems has its own share of advantages and disadvantages:
for instance, rotation matrices are handy when you have a vector and
want to rotate it, as it’s just a matter of doing a matrix-vector
multiplication. Quaternions are more complicated on this regard, but
they offer a mathematical operation called <em>slerp</em> (shorthand for
<em>spherical linear interpolation</em>), which is incredibly useful and not
available with other representations, like rotation matrices. We
assume that the reader knows what quaternion are and their
mathematical properties; if you are not, be sure to read the book
<em>Visualizing quaternions</em>, by Andrew J. Hanson (Elsevier, 2006,
ISBN-0080474772) and the provocative essay by Marc ten Bosch, <a class="reference external" href="https://marctenbosch.com/quaternions/">Let’s
remove Quaternions from every 3D engine</a>.</p>
<p>The LiteBIRD simulation framework models quaternions using the
convention <span class="math notranslate nohighlight">\((v_x, v_y, v_z, w)\)</span>; be aware that some textbooks
use the order <span class="math notranslate nohighlight">\(w, v_x, v_y, v_z\)</span>. As the framework uses
quaternions only to model rotations, they all must obey the relation
<span class="math notranslate nohighlight">\(v_x^2 + v_y^2 + v_z^2 + w^2 = 1\)</span> (<em>normalized</em> quaternions),
which is a property satisfied by rotation quaternions.</p>
</div>
<div class="section" id="python-functions-for-quaternions">
<h3>Python functions for quaternions<a class="headerlink" href="#python-functions-for-quaternions" title="Permalink to this headline">¶</a></h3>
<p>The LiteBIRD Simulation Framework provides three functions,
<code class="xref py py-func docutils literal notranslate"><span class="pre">qrotation_x()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">qrotation_y()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">qrotation_z()</span></code> to
compute simple rotation quaternions; they return the normalized
quaternion representing a rotation by an angle <span class="math notranslate nohighlight">\(\theta\)</span> around
one of the three axis <cite>x</cite>, <cite>y</cite>, and <cite>z</cite>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">litebird_sim</span> <span class="k">as</span> <span class="nn">lbs</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">print_quaternion</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:.3f}</span><span class="s2"> </span><span class="si">{:.3f}</span><span class="s2"> </span><span class="si">{:.3f}</span><span class="s2"> </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rotation by π/3 around x:&quot;</span><span class="p">)</span>
<span class="n">print_quaternion</span><span class="p">(</span><span class="n">lbs</span><span class="o">.</span><span class="n">qrotation_x</span><span class="p">(</span><span class="n">theta_rad</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rotation by π/3 around y:&quot;</span><span class="p">)</span>
<span class="n">print_quaternion</span><span class="p">(</span><span class="n">lbs</span><span class="o">.</span><span class="n">qrotation_y</span><span class="p">(</span><span class="n">theta_rad</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rotation by π/3 around z:&quot;</span><span class="p">)</span>
<span class="n">print_quaternion</span><span class="p">(</span><span class="n">lbs</span><span class="o">.</span><span class="n">qrotation_z</span><span class="p">(</span><span class="n">theta_rad</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Rotation by π/3 around x:
0.500 0.000 0.000 0.866
Rotation by π/3 around y:
0.000 0.500 0.000 0.866
Rotation by π/3 around z:
0.000 0.000 0.500 0.866
</pre></div>
</div>
<p>There are two functions that implement in-place multiplication of
quaternions: <code class="xref py py-func docutils literal notranslate"><span class="pre">quat_right_multiply()</span></code> performs the calculation
<span class="math notranslate nohighlight">\(r \leftarrow r \times q\)</span>, and <code class="xref py py-func docutils literal notranslate"><span class="pre">quat_left_multiply()</span></code>
performs the calculation <span class="math notranslate nohighlight">\(r \leftarrow q \times r\)</span> (where
<span class="math notranslate nohighlight">\(\leftarrow\)</span> indicates the assignment operation):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">quat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lbs</span><span class="o">.</span><span class="n">qrotation_x</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">lbs</span><span class="o">.</span><span class="n">quat_left_multiply</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="o">*</span><span class="n">lbs</span><span class="o">.</span><span class="n">qrotation_z</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rotation by π/3 around x and then by π/2 around z:&quot;</span><span class="p">)</span>
<span class="n">print_quaternion</span><span class="p">(</span><span class="n">quat</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Rotation by π/3 around x and then by π/2 around z:
0.354 0.354 0.612 0.612
</pre></div>
</div>
<p>Note the syntax for <code class="xref py py-func docutils literal notranslate"><span class="pre">quat_left_multiply()</span></code>: you are supposed to
pass the four components of the quaternion <span class="math notranslate nohighlight">\(q\)</span> as separate
arguments, and thus we need to prepend the call to <code class="docutils literal notranslate"><span class="pre">lbs.qrotation_z</span></code>
with <code class="docutils literal notranslate"><span class="pre">*</span></code> to expand the result (a 4-element tuple) into the four
parameters required by <code class="xref py py-func docutils literal notranslate"><span class="pre">quat_left_multiply()</span></code>. The reason for
this weird syntax is efficiency, as this kind of function call can be
easily optimized by Numba (which is used extensively in the code).</p>
</div>
<div class="section" id="id2">
<h3>Custom scanning strategies<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>We are now ready to discuss how to implement other types of scanning
strategies. There are plenty of reasons why one would like to go
beyond the class <code class="xref py py-class docutils literal notranslate"><span class="pre">SpinningScanningStrategy</span></code>:</p>
<ol class="arabic simple">
<li><p>You want to study the effect of non-idealities, like second-order
effects caused by contractions/dilations in the mechanical
structure of the telescope that make the angle between the spin
axis and the boresight vary with time.</p></li>
<li><p>You are thinking about how to make dedicated observations of some
celestial source (e.g., the Crab Nebula) for the purpose of
calibrating the instruments.</p></li>
</ol>
<p>To define a new scanning strategy, we define a descendeant of the
<code class="xref py py-class docutils literal notranslate"><span class="pre">ScanningStrategy</span></code> class, an <a class="reference external" href="https://docs.python.org/3/library/abc.html">Abstract Base Class (ABC)</a>; the only method that
must be defined is
<a class="reference internal" href="#litebird_sim.scanning.ScanningStrategy.generate_bore2ecl_quaternions" title="litebird_sim.scanning.ScanningStrategy.generate_bore2ecl_quaternions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ScanningStrategy.generate_bore2ecl_quaternions()</span></code></a>, which takes
as inputs the start time, the length of the simulation, and the time
interval to be used between consecutive quaternions. The method must
return an instance of the <a class="reference internal" href="#litebird_sim.scanning.Bore2EclipticQuaternions" title="litebird_sim.scanning.Bore2EclipticQuaternions"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bore2EclipticQuaternions</span></code></a>,
containing the computed sequence of quaternions.</p>
<p>We’ll code here a very simple scanning strategy, which does not
involve anything fancy: the spacecraft will just spin around the
Sun-Earth axis, and the boresight direction will be along the same
spin axis. Thus, the boresight detector is going to see only the
points along the Ecliptic plane. This scanning strategy is
scientifically useless, but it’s simple enough to be implemented in a
few lines of code:</p>
<ol class="arabic simple">
<li><p>The transformation from boresight to the spin axis reference frame
is the identity;</p></li>
<li><p>There is no precession of the spin axis; therefore, the latter
stays on the Ecliptic axis;</p></li>
<li><p>The only rotation is caused by the revolution of the Sun-Earth axis
around the Sun, which is implemented as a rotation on the <cite>xy</cite>
plane, i.e., around the <cite>z</cite> axis.</p></li>
</ol>
<p>The following code implements our mock scanning strategy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SimpleScanningStrategy</span><span class="p">(</span><span class="n">lbs</span><span class="o">.</span><span class="n">ScanningStrategy</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">generate_bore2ecl_quaternions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">time_span_s</span><span class="p">,</span> <span class="n">delta_time_s</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Compute how many quaternions are needed to cover</span>
        <span class="c1"># the time interval specified by &quot;time_span_s&quot;</span>
        <span class="n">num_of_quaternions</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">lbs</span><span class="o">.</span><span class="n">ScanningStrategy</span><span class="o">.</span><span class="n">optimal_num_of_quaternions</span><span class="p">(</span>
                <span class="n">time_span_s</span><span class="o">=</span><span class="n">time_span_s</span><span class="p">,</span>
                <span class="n">delta_time_s</span><span class="o">=</span><span class="n">delta_time_s</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Make room for the quaternions</span>
        <span class="n">bore2ecliptic_quats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_of_quaternions</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

        <span class="c1"># We compute the times when the quaternions need to be</span>
        <span class="c1"># calculated. Note that ScanningStrategy returns two</span>
        <span class="c1"># arrays (&quot;time&quot; and &quot;time_s&quot;), but we neglect the second</span>
        <span class="c1"># because we don&#39;t need it in this very simple case</span>
        <span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">ScanningStrategy</span><span class="o">.</span><span class="n">get_times</span><span class="p">(</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
            <span class="n">delta_time_s</span><span class="o">=</span><span class="n">delta_time_s</span><span class="p">,</span>
            <span class="n">num_of_quaternions</span><span class="o">=</span><span class="n">num_of_quaternions</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Compute the angle on the Ecliptic plane between the x</span>
        <span class="c1"># axis and the Sun-Earth axis, possibly using AstroPy</span>
        <span class="n">sun_earth_angles_rad</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">lbs</span><span class="o">.</span><span class="n">calculate_sun_earth_angles_rad</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># This code is *not* optimized: in a real-world case,</span>
        <span class="c1"># you&#39;ll probably want to use Numba instead of the</span>
        <span class="c1"># following &quot;for&quot; loop</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_of_quaternions</span><span class="p">):</span>
            <span class="c1"># Rotate by 90° around the y axis (move the boresight</span>
            <span class="c1"># to the Ecliptic xy plane)</span>
            <span class="n">bore2ecliptic_quats</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">qrotation_y</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Simulate the revolution of the spacecraft around</span>
            <span class="c1"># the Sun using the angles computed above</span>
            <span class="n">lbs</span><span class="o">.</span><span class="n">quat_left_multiply</span><span class="p">(</span>
                <span class="n">bore2ecliptic_quats</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                <span class="o">*</span><span class="n">lbs</span><span class="o">.</span><span class="n">qrotation_z</span><span class="p">(</span><span class="n">sun_earth_angles_rad</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
            <span class="p">)</span>

        <span class="c1"># Return the quaternions wrapped in an instance of</span>
        <span class="c1"># &quot;Bore2EclipticQuaternions&quot;</span>
        <span class="k">return</span> <span class="n">lbs</span><span class="o">.</span><span class="n">Bore2EclipticQuaternions</span><span class="p">(</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
            <span class="n">pointing_freq_hz</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">delta_time_s</span><span class="p">,</span>
            <span class="n">quats</span><span class="o">=</span><span class="n">bore2ecliptic_quats</span><span class="p">,</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>To test the class <code class="docutils literal notranslate"><span class="pre">SimpleScanningStrategy</span></code>, we write some code very
similar to the example presented at the beginning of this section.
However, we cannot run the simulation for just one hour, as it would
be not enough to see any change in the pointing direction: the only
things that changes as time passes is the position of the Earth on the
Ecliptic plane, and it takes 365 days to do one revolution. Therefore,
we extend the length of the simulation to 365 days. Of course, there
is no need to use an high sampling frequency in our example, so we use
here just one sample per day; for the same reason, instead of
computing one quaternion every minute, we compute one quaternion every
30 days:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">astropy.units</span> <span class="k">as</span> <span class="nn">u</span>
<span class="kn">import</span> <span class="nn">healpy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">sim</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span>
    <span class="n">start_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">duration_s</span><span class="o">=</span><span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Sample simulation&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">sim</span><span class="o">.</span><span class="n">generate_bore2ecl_quaternions</span><span class="p">(</span>
    <span class="n">scanning_strategy</span><span class="o">=</span><span class="n">SimpleScanningStrategy</span><span class="p">(),</span>
    <span class="n">delta_time_s</span><span class="o">=</span><span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
<span class="p">)</span>

<span class="n">det</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">Detector</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span>
    <span class="n">sampling_rate_hz</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
<span class="p">)</span>
<span class="p">(</span><span class="n">obs</span><span class="p">,)</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">create_observations</span><span class="p">(</span><span class="n">detectors</span><span class="o">=</span><span class="p">[</span><span class="n">det</span><span class="p">])</span>
<span class="n">pointings</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">get_pointings</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">bore2ecliptic_quats</span><span class="p">,</span> <span class="n">det</span><span class="o">.</span><span class="n">quat</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">healpy</span><span class="o">.</span><span class="n">nside2npix</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
<span class="n">pixidx</span> <span class="o">=</span> <span class="n">healpy</span><span class="o">.</span><span class="n">ang2pix</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">pointings</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pointings</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">m</span><span class="p">[</span><span class="n">pixidx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">healpy</span><span class="o">.</span><span class="n">mollview</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is the result: we’re indeed scanning the Ecliptic plane!</p>
<img alt="_images/simple-scanning-strategy.png" src="_images/simple-scanning-strategy.png" />
</div>
</div>
<div class="section" id="module-litebird_sim.scanning">
<span id="api-reference"></span><h2>API reference<a class="headerlink" href="#module-litebird_sim.scanning" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="litebird_sim.scanning.Bore2EclipticQuaternions">
<em class="property">class </em><code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">Bore2EclipticQuaternions</code><span class="sig-paren">(</span><em class="sig-param">start_time: Union[float, astropy.time.core.Time], pointing_freq_hz: float, quats</em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.Bore2EclipticQuaternions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A matrix of quaternions sampled uniformly over time</p>
<p>This class is used to hold quaternions that represent the
transformation from the boresight reference frame of the LiteBIRD
spacecraft to the Ecliptic reference frame.</p>
<p>The class has the following members:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">start_time</span></code> is either a floating-point number or an
<code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code> object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pointing_freq_hz</span></code> is the sampling frequency of the
quaternions, in Hertz</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">quats</span></code> is a NumPy array of shape <code class="docutils literal notranslate"><span class="pre">(N</span> <span class="pre">×</span> <span class="pre">4)</span></code>, containing the
<code class="docutils literal notranslate"><span class="pre">N</span></code> (normalized) quaternions</p></li>
</ul>
<dl class="method">
<dt id="litebird_sim.scanning.Bore2EclipticQuaternions.get_detector_quats">
<code class="sig-name descname">get_detector_quats</code><span class="sig-paren">(</span><em class="sig-param">detector_quat, time0: Union[float, astropy.time.core.Time], sampling_rate_hz: float, nsamples: int</em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.Bore2EclipticQuaternions.get_detector_quats" title="Permalink to this definition">¶</a></dt>
<dd><p>Return detector-to-Ecliptic quaternions</p>
<p>This method combines the boresight-to-Ecliptic quaternions in
<code class="docutils literal notranslate"><span class="pre">self.quat</span></code> with an additional rotation (<cite>detector_quat</cite>),
representing the transformation from the reference frame of a
detector to the boresight reference frame. The result is a
quaternion that directly transforms the reference frame of the
detector to Ecliptic coordinates.</p>
<p>As this kind of quaternion is used to compute the pointings of
a detector, which are used in map-making, it applies a «slerp»
operation on the quaternion, oversampling them to the sampling
frequency of the detector, expressed through the parameter
<cite>sampling_rate_hz</cite>.</p>
<p>The parameters <cite>time0</cite> and <cite>nsamples</cite> specify which is the
time interval that needs to be covered by the quaternions
computed by this method. The type of the parameter <cite>time0</cite>
must match that of <cite>self.start_time</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="litebird_sim.scanning.Bore2EclipticQuaternions.nbytes">
<code class="sig-name descname">nbytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.Bore2EclipticQuaternions.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of bytes allocated for the quaternions</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="litebird_sim.scanning.ScanningStrategy">
<em class="property">class </em><code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">ScanningStrategy</code><a class="headerlink" href="#litebird_sim.scanning.ScanningStrategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>A class that simulate a scanning strategy</p>
<p>This is an abstract base class; you should probably use
<a class="reference internal" href="#litebird_sim.scanning.SpinningScanningStrategy" title="litebird_sim.scanning.SpinningScanningStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinningScanningStrategy</span></code></a>, unless you are interested in
simulating other kinds of scanning strategies. If this is the
case, refer to the documentation.</p>
<dl class="method">
<dt id="litebird_sim.scanning.ScanningStrategy.generate_bore2ecl_quaternions">
<em class="property">abstract </em><code class="sig-name descname">generate_bore2ecl_quaternions</code><span class="sig-paren">(</span><em class="sig-param">start_time: Union[float, astropy.time.core.Time], time_span_s: float, delta_time_s: float</em><span class="sig-paren">)</span> &#x2192; litebird_sim.scanning.Bore2EclipticQuaternions<a class="headerlink" href="#litebird_sim.scanning.ScanningStrategy.generate_bore2ecl_quaternions" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the quaternions for boresight to Ecliptic rotations</p>
<p>This method simulates the scanning strategy of the spacecraft
assuming that the mission begins at some time <cite>start_time</cite> and
lasts for <cite>time_span_s</cite> seconds. The purpose of the function
is to compute the orientation of the spacecraft once every
<cite>delta_time_s</cite> seconds for the whole duration of the mission;
the orientation is expressed as a quaternion that encodes the
rotation from the boresight reference frame (aligned with the
y axis) to the reference frame of the Ecliptic Coordinate
System.</p>
<p>The function returns a <a class="reference internal" href="#litebird_sim.scanning.Bore2EclipticQuaternions" title="litebird_sim.scanning.Bore2EclipticQuaternions"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bore2EclipticQuaternions</span></code></a>
object that fully covers the time interval between
<cite>start_time</cite> and <cite>start_time + time_span_s</cite>: this means that
an additional quaternion <em>after</em> the time <code class="docutils literal notranslate"><span class="pre">t_end</span> <span class="pre">=</span> <span class="pre">start_time</span>
<span class="pre">+</span> <span class="pre">time_span_s</span></code> might be appended.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_time</strong> (<em>Union</em><em>[</em><em>float</em><em>, </em><em>astropy.time.Time</em><em>]</em>) – start time
of the simulation. If it is a floating-point number,
it is arbitrary and can usually be set to 0.0;
otherwise, it must be a <code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code> object,
and in this case a more precise computation of the
orientation of the spacecraft is used. Depending on
the duration of the simulation, the second case can be
a few orders of magnitude slower: it should be used
only when the simulation needs to track the position
of moving objects (e.g., planets).</p></li>
<li><p><strong>time_span_s</strong> (<em>float</em>) – interval of time that needs to be
simulated, in seconds. These seconds are added to
<cite>start_time</cite>, and their meaning depends on its type:
if <cite>start_time</cite> is a float, you should consider the
duration as a sidereal time, but if it’s a
<cite>astropy.time.Time</cite> time, <cite>time_span_s</cite> is expressed
as a Solar time.</p></li>
<li><p><strong>delta_time_s</strong> (<em>float</em>) – for efficiency, quaternions are not
sampled at the same sample rate as the scientific
data, but at a much lower rate. The default should be
good for all the most common cases, but you can tune
it with this parameter.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="litebird_sim.scanning.ScanningStrategy.get_times">
<em class="property">static </em><code class="sig-name descname">get_times</code><span class="sig-paren">(</span><em class="sig-param">start_time: Union[float, astropy.time.core.Time], delta_time_s: float, num_of_quaternions: int</em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.ScanningStrategy.get_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vector of equally-separated times</p>
<p>Depending on the type of the parameter <cite>start_time</cite> (either a
<code class="docutils literal notranslate"><span class="pre">float</span></code> or a <code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code> instance), return a
vector of times that mark the instant when a quaternion must
be computed by the class.</p>
<p>The class returns a 2-element tuple, containing (1) the time
expressed using the same type as <cite>start_time</cite> (either
<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code>), and (2) a vector
containing the time measured in seconds. The latter is useful
when your scanning strategy depends on the time for the
computation of angles and rotation, e.g., if you need to
compute <span class="math notranslate nohighlight">\(2\pi\nu t\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="litebird_sim.scanning.ScanningStrategy.optimal_num_of_quaternions">
<em class="property">static </em><code class="sig-name descname">optimal_num_of_quaternions</code><span class="sig-paren">(</span><em class="sig-param">time_span_s: float</em>, <em class="sig-param">delta_time_s: float</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#litebird_sim.scanning.ScanningStrategy.optimal_num_of_quaternions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of quaternions to compute</p>
<p>Given a time span and a time interval between consecutive
quaternions, this static method computes how many quaternions
are needed to properly cover the time span.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="litebird_sim.scanning.SpinningScanningStrategy">
<em class="property">class </em><code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">SpinningScanningStrategy</code><span class="sig-paren">(</span><em class="sig-param">spin_sun_angle_deg</em>, <em class="sig-param">spin_boresight_angle_deg</em>, <em class="sig-param">precession_period_min</em>, <em class="sig-param">spin_rate_rpm</em>, <em class="sig-param">start_time=&lt;Time object: scale='tdb' format='iso' value=2027-01-01 00:00:00.000&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.SpinningScanningStrategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#litebird_sim.scanning.ScanningStrategy" title="litebird_sim.scanning.ScanningStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">litebird_sim.scanning.ScanningStrategy</span></code></a></p>
<p>A class containing the parameters of the sky scanning strategy</p>
<p>This class is used to hold together the parameters that define the
nominal scanning strategy of the LiteBIRD spacecraft. It’s a
simple scanning strategy that closely matches the ones proposed
for other CMB experiments from space like CORE and Pico: a
spinning motion of the spacecraft around some axis, composed with
a precession motion around the Sun-Earth-spacecraft axis (assuming
that the spacecraft flies around the L_2 point of the Sun-Earth
system).</p>
<p>The constructor accepts the following parameters:</p>
<ul class="simple">
<li><p><cite>spin_sun_angle_deg</cite>: angle between the spin axis and the
Sun-LiteBIRD direction (floating-point number, in degrees)</p></li>
<li><p><cite>spin_boresight_angle_deg</cite>: angle between the boresight
direction and the spin axis (floating-point number, in degrees)</p></li>
<li><p><cite>precession_period_min</cite>: the period of the precession rotation
(floating-point number, in minutes)</p></li>
<li><p><cite>spin_rate_rpm</cite>: the number of rotations per minute (RPM) around
the spin axis (floating-point number)</p></li>
<li><p><cite>start_time</cite>: an <code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code> object representing the
start of the observation. It’s currently unused, but it is meant
to represent the time when the rotation starts (i.e., the angle
ωt is zero).</p></li>
</ul>
<p>Once the object is created, the following fields are available:</p>
<ul class="simple">
<li><p><cite>spin_sun_angle_rad</cite>: the same as <cite>spin_sun_angle_deg</cite>, but in
radians</p></li>
<li><p><cite>spin_boresight_angle_rad</cite>: the same as
<cite>spin_boresight_angle_deg</cite>, but in radians</p></li>
<li><p><cite>precession_rate_hz</cite>: the frequency of the precession rotation,
in Hertz, or zero if no precession occurs (i.e.,
<cite>precession_period_min</cite> is zero)</p></li>
<li><p><cite>spin_rate_hz</cite>: the frequency of the spin rotation, in Hertz</p></li>
<li><p><cite>start_time</cite>: see above</p></li>
</ul>
<p>You can create an instance of this class using the class method
<a class="reference internal" href="#litebird_sim.scanning.SpinningScanningStrategy.from_imo" title="litebird_sim.scanning.SpinningScanningStrategy.from_imo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_imo()</span></code></a>, which reads the
parameters from the IMO.</p>
<dl class="method">
<dt id="litebird_sim.scanning.SpinningScanningStrategy.all_boresight_to_ecliptic">
<code class="sig-name descname">all_boresight_to_ecliptic</code><span class="sig-paren">(</span><em class="sig-param">result_matrix</em>, <em class="sig-param">sun_earth_angles_rad</em>, <em class="sig-param">time_vector_s</em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.SpinningScanningStrategy.all_boresight_to_ecliptic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="litebird_sim.scanning.SpinningScanningStrategy.from_imo">
<em class="property">classmethod </em><code class="sig-name descname">from_imo</code><span class="sig-paren">(</span><em class="sig-param">imo: litebird_sim.imo.imo.Imo, url: Union[str, uuid.UUID]</em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.SpinningScanningStrategy.from_imo" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the definition of the scanning strategy from the IMO</p>
<p>This function returns a <a class="reference internal" href="#litebird_sim.scanning.SpinningScanningStrategy" title="litebird_sim.scanning.SpinningScanningStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinningScanningStrategy</span></code></a>
object containing the set of parameters that define the
scanning strategy of the spacecraft, i.e., the way it observes
the sky during the nominal mission.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imo</strong> (<a class="reference internal" href="imo.html#litebird_sim.imo.Imo" title="litebird_sim.imo.Imo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imo</span></code></a>) – an instance of the <a class="reference internal" href="imo.html#litebird_sim.imo.Imo" title="litebird_sim.imo.Imo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imo</span></code></a> class</p></li>
<li><p><strong>url</strong> (str or <code class="docutils literal notranslate"><span class="pre">UUID</span></code>) – a reference to the data file
containing the definition of the scanning strategy. It can
be either a string like
<code class="docutils literal notranslate"><span class="pre">/releases/v1.0/satellite/scanning_parameters/</span></code> or a
UUID.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">imo</span> <span class="o">=</span> <span class="n">Imo</span><span class="p">()</span>
<span class="n">sstr</span> <span class="o">=</span> <span class="n">SpinningScanningStrategy</span><span class="o">.</span><span class="n">from_imo</span><span class="p">(</span>
    <span class="n">imo</span><span class="o">=</span><span class="n">imo</span><span class="p">,</span>
    <span class="n">url</span><span class="o">=</span><span class="s2">&quot;/releases/v1.0/satellite/scanning_parameters/&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sstr</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="litebird_sim.scanning.SpinningScanningStrategy.generate_bore2ecl_quaternions">
<code class="sig-name descname">generate_bore2ecl_quaternions</code><span class="sig-paren">(</span><em class="sig-param">start_time: Union[float, astropy.time.core.Time], time_span_s: float, delta_time_s: float</em><span class="sig-paren">)</span> &#x2192; litebird_sim.scanning.Bore2EclipticQuaternions<a class="headerlink" href="#litebird_sim.scanning.SpinningScanningStrategy.generate_bore2ecl_quaternions" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the quaternions for boresight to Ecliptic rotations</p>
<p>This method simulates the scanning strategy of the spacecraft
assuming that the mission begins at some time <cite>start_time</cite> and
lasts for <cite>time_span_s</cite> seconds. The purpose of the function
is to compute the orientation of the spacecraft once every
<cite>delta_time_s</cite> seconds for the whole duration of the mission;
the orientation is expressed as a quaternion that encodes the
rotation from the boresight reference frame (aligned with the
y axis) to the reference frame of the Ecliptic Coordinate
System.</p>
<p>The function returns a <a class="reference internal" href="#litebird_sim.scanning.Bore2EclipticQuaternions" title="litebird_sim.scanning.Bore2EclipticQuaternions"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bore2EclipticQuaternions</span></code></a>
object that fully covers the time interval between
<cite>start_time</cite> and <cite>start_time + time_span_s</cite>: this means that
an additional quaternion <em>after</em> the time <code class="docutils literal notranslate"><span class="pre">t_end</span> <span class="pre">=</span> <span class="pre">start_time</span>
<span class="pre">+</span> <span class="pre">time_span_s</span></code> might be appended.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_time</strong> (<em>Union</em><em>[</em><em>float</em><em>, </em><em>astropy.time.Time</em><em>]</em>) – start time
of the simulation. If it is a floating-point number,
it is arbitrary and can usually be set to 0.0;
otherwise, it must be a <code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code> object,
and in this case a more precise computation of the
orientation of the spacecraft is used. Depending on
the duration of the simulation, the second case can be
a few orders of magnitude slower: it should be used
only when the simulation needs to track the position
of moving objects (e.g., planets).</p></li>
<li><p><strong>time_span_s</strong> (<em>float</em>) – interval of time that needs to be
simulated, in seconds. These seconds are added to
<cite>start_time</cite>, and their meaning depends on its type:
if <cite>start_time</cite> is a float, you should consider the
duration as a sidereal time, but if it’s a
<cite>astropy.time.Time</cite> time, <cite>time_span_s</cite> is expressed
as a Solar time.</p></li>
<li><p><strong>delta_time_s</strong> (<em>float</em>) – for efficiency, quaternions are not
sampled at the same sample rate as the scientific
data, but at a much lower rate. The default should be
good for all the most common cases, but you can tune
it with this parameter.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.all_boresight_to_ecliptic">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">all_boresight_to_ecliptic</code><a class="headerlink" href="#litebird_sim.scanning.all_boresight_to_ecliptic" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the <a class="reference internal" href="#litebird_sim.scanning.boresight_to_ecliptic" title="litebird_sim.scanning.boresight_to_ecliptic"><code class="xref py py-func docutils literal notranslate"><span class="pre">boresight_to_ecliptic()</span></code></a> function to the rows of a matrix</p>
<p>This function extends <a class="reference internal" href="#litebird_sim.scanning.boresight_to_ecliptic" title="litebird_sim.scanning.boresight_to_ecliptic"><code class="xref py py-func docutils literal notranslate"><span class="pre">boresight_to_ecliptic()</span></code></a> to work with
the vector of times <cite>time_vector_s</cite>; all the other parameters must
still be float as in <cite>boresight_to_ecliptic</cite>; the variable
<cite>result_matrix</cite> must be a matrix of shape <code class="docutils literal notranslate"><span class="pre">(len(time_vector_s),</span>
<span class="pre">4)</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.all_compute_pointing_and_polangle">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">all_compute_pointing_and_polangle</code><a class="headerlink" href="#litebird_sim.scanning.all_compute_pointing_and_polangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeatedly apply <cite>compute_pointing_and_polangle</cite></p>
<p>Assuming that <cite>result_matrix</cite> is a (N×3) matrix and <cite>quat_matrix</cite>
a (N×4) matrix, iterate over all the N rows and apply
<a class="reference internal" href="#litebird_sim.scanning.compute_pointing_and_polangle" title="litebird_sim.scanning.compute_pointing_and_polangle"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_pointing_and_polangle()</span></code></a> to every row.</p>
</dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.boresight_to_ecliptic">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">boresight_to_ecliptic</code><a class="headerlink" href="#litebird_sim.scanning.boresight_to_ecliptic" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a quaternion with the boresight-to-Ecliptic rotation</p>
<p>This function computes the (normalized) quaternion that encodes
the rotation which transforms the boresight frame of reference
into the Ecliptic frame of reference. The result is saved in the
parameter <cite>result</cite>, which must be a 4-element NumPy array; the
order of the elements of the quaternion is <cite>(vx, vy, vz, w)</cite>.</p>
<p>The function computes the quaternion as the following sequence of
rotations:</p>
<ol class="arabic simple">
<li><p>A rotation around the <cite>y</cite> axis by the angle
<cite>spin_boresight_angle_rad</cite> (from the boresight reference frame
to the spin-axis reference frame)</p></li>
<li><p>A rotation around the <cite>z</cite> axis by the angle <span class="math notranslate nohighlight">\(2π ν t\)</span>,
with <cite>ν</cite> being the parameter <cite>spin_rate_hz</cite> and <cite>t</cite> the
parameter <cite>time_s</cite> (this rotation accounts for the rotation of
the spacecraft around the spin axis)</p></li>
<li><p>A rotation around the <cite>y</cite> axis by the angle <span class="math notranslate nohighlight">\(π/2 -
\alpha\)</span>, with <cite>ɑ</cite> being the parameter <cite>spin_sun_angle_rad</cite>
(this accounts for the inclination of the spin axis with
respect to the Ecliptic plane)</p></li>
<li><p>A rotation around the <cite>x</cite> axis by the angle <span class="math notranslate nohighlight">\(2π ν t\)</span>,
with <cite>ν</cite> being the parameter <cite>precession_rate_hz</cite> and <cite>t</cite> the
parameter <cite>time_s</cite> (this rotation accounts for the rotation of
the spin axis because of the precessional motion)</p></li>
<li><p>A rotation around the <cite>z</cite> axis by the angle
<cite>sun_earth_angle_rad</cite> (this accounts for the yearly revolution
of the spacecraft around the Sun)</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sun_earth_angle_rad</strong> (<em>float</em>) – Angle between the x axis and the
Sun-Earth direction on the xy Ecliptic plane (in radians)</p></li>
<li><p><strong>spin_sun_angle_rad</strong> (<em>float</em>) – Angle between the spin axis of
the spacecraft and the Sun-Earth direction (in radians);
this angle is sometimes called <cite>ɑ</cite></p></li>
<li><p><strong>spin_boresight_angle_rad</strong> (<em>float</em>) – Angle between the boresight
direction of the spacecraft and its spin axis (in radians);
this angle is sometimes called <cite>β</cite></p></li>
<li><p><strong>precession_rate_hz</strong> (<em>float</em>) – The frequency of rotations around
the precession axis (in rotations/sec)</p></li>
<li><p><strong>spin_rate_hz</strong> (<em>float</em>) – The frequency of rotations around the
spin axis (in rotations/sec)</p></li>
<li><p><strong>time_s</strong> (<em>float</em>) – the time when to compute the quaternion</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="litebird_sim.scanning.calculate_sun_earth_angles_rad">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">calculate_sun_earth_angles_rad</code><span class="sig-paren">(</span><em class="sig-param">time_vector</em><span class="sig-paren">)</span><a class="headerlink" href="#litebird_sim.scanning.calculate_sun_earth_angles_rad" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the angle between the x axis and the Earth</p>
<p>This function computes the angle on the plane of the Ecliptic
(assuming to be the xy plane) between the Sun-Earth direction and
the x axis. Depending on the type of the parameter <cite>time_vector</cite>,
the result is computed differently:</p>
<ul class="simple">
<li><p>If <cite>time_vector</cite> is a <code class="docutils literal notranslate"><span class="pre">astropy.time.Time</span></code> object, the angle is
computed using the Barycentric Mean Ecliptic reference frame and
the Ephemerides tables provided by AstroPy (slow but accurate)</p></li>
<li><p>Otherwise, <cite>time_vector</cite> is assumed to be a NumPy array of
floats, and a simple circular motion with constant angular
velocity is assumed. The angular velocity is
<code class="docutils literal notranslate"><span class="pre">YEARLY_OMEGA_SPIN_HZ</span></code>, which is equal to <span class="math notranslate nohighlight">\(2π/T\)</span>, with T
being the average duration of one year in seconds, and it is
assumed that at time <cite>t = 0</cite> the angle is zero.</p></li>
</ul>
</dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.clip_sincos">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">clip_sincos</code><a class="headerlink" href="#litebird_sim.scanning.clip_sincos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.compute_pointing_and_polangle">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">compute_pointing_and_polangle</code><a class="headerlink" href="#litebird_sim.scanning.compute_pointing_and_polangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Store in “result” the pointing direction and polarization angle.</p>
<p>The function assumes that <cite>quaternion</cite> encodes a rotation which
transforms the z axis into the direction of a beam in the sky,
i.e., it assumes that the beam points towards z in its own
reference frame and that <cite>quaternion</cite> transforms the reference
frame to celestial coordinates.</p>
<p>The variable <cite>result</cite> is used to save the result of the
computation, and it should be a 3-element NumPy array. On exit,
its values will be:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">result[0]</span></code>: the colatitude of the sky direction, in radians</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">result[1]</span></code>: the longitude of the sky direction, in radians</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">result[2]</span></code>: the polarization angle (assuming that in the beam
reference frame points towards x), measured with respect to the
North and East directions in the celestial sphere</p></li>
</ul>
<p>This function does <em>not</em> support broadcasting; use
<cite>all_compute_pointing_and_polangle</cite> if you need to transform
several quaternions at once.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">compute_pointing_and_polangle</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.polarization_angle">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">polarization_angle</code><a class="headerlink" href="#litebird_sim.scanning.polarization_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the polarization angle at a given point on the sky</p>
<p>This function returns the polarization angle (in radians) with
respect to the North Pole of the celestial sphere for the point at
coordinates <cite>theta_rad</cite> (colatitude, in radians) and <cite>phi_rad</cite>
(longitude, in radians), assuming that <cite>poldir</cite> is a 3-element
NumPy array representing a normalized vector which departs from
the point on the celestial sphere and is aligned with the
polarization direction.</p>
</dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.qrotation_x">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">qrotation_x</code><a class="headerlink" href="#litebird_sim.scanning.qrotation_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a quaternion representing a rotation around the x axis</p>
<p>The angle <cite>theta_rad</cite> must be expressed in radians. The return
value is the quaternion, using the order <code class="docutils literal notranslate"><span class="pre">(v_x,</span> <span class="pre">v_y,</span> <span class="pre">v_z,</span> <span class="pre">w)</span></code>;
it is returned as a 4-element tuple.</p>
<p>The fact that the result is a tuple instead of a NumPy array is
because of speed: it helps in preventing unnecessary allocations
in performance-critical code.</p>
<p>See also <a class="reference internal" href="#litebird_sim.scanning.qrotation_y" title="litebird_sim.scanning.qrotation_y"><code class="xref py py-func docutils literal notranslate"><span class="pre">qrotation_y()</span></code></a> and <a class="reference internal" href="#litebird_sim.scanning.qrotation_z" title="litebird_sim.scanning.qrotation_z"><code class="xref py py-func docutils literal notranslate"><span class="pre">qrotation_z()</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.qrotation_y">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">qrotation_y</code><a class="headerlink" href="#litebird_sim.scanning.qrotation_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a quaternion representing a rotation around the y axis</p>
<p>See also <a class="reference internal" href="#litebird_sim.scanning.qrotation_x" title="litebird_sim.scanning.qrotation_x"><code class="xref py py-func docutils literal notranslate"><span class="pre">qrotation_x()</span></code></a> and <a class="reference internal" href="#litebird_sim.scanning.qrotation_z" title="litebird_sim.scanning.qrotation_z"><code class="xref py py-func docutils literal notranslate"><span class="pre">qrotation_z()</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.qrotation_z">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">qrotation_z</code><a class="headerlink" href="#litebird_sim.scanning.qrotation_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a quaternion representing a rotation around the y axis</p>
<p>See also <a class="reference internal" href="#litebird_sim.scanning.qrotation_x" title="litebird_sim.scanning.qrotation_x"><code class="xref py py-func docutils literal notranslate"><span class="pre">qrotation_x()</span></code></a> and <a class="reference internal" href="#litebird_sim.scanning.qrotation_y" title="litebird_sim.scanning.qrotation_y"><code class="xref py py-func docutils literal notranslate"><span class="pre">qrotation_y()</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.quat_left_multiply">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">quat_left_multiply</code><a class="headerlink" href="#litebird_sim.scanning.quat_left_multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a multiplication between two quaternions</p>
<p>This function implements the computation <span class="math notranslate nohighlight">\(r = q \times r\)</span>;
see also <a class="reference internal" href="#litebird_sim.scanning.quat_right_multiply" title="litebird_sim.scanning.quat_right_multiply"><code class="xref py py-func docutils literal notranslate"><span class="pre">quat_right_multiply()</span></code></a> for the computation <span class="math notranslate nohighlight">\(r
= r\times q\)</span>.</p>
<p>It’s easy to use NumPy quaternions for <cite>q</cite> as well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">])</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">])</span>
<span class="n">quat_right_multiply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>  <span class="c1"># Unpack &quot;q&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result:&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.quat_right_multiply">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">quat_right_multiply</code><a class="headerlink" href="#litebird_sim.scanning.quat_right_multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a multiplication between two quaternions</p>
<p>This function implements the computation <span class="math notranslate nohighlight">\(r = r       imes q\)</span>,
where <cite>r</cite> is the parameter <cite>result</cite> (a 3-element NumPy array) and
<cite>q</cite> is the set of parameters <cite>other_v1</cite>, <cite>other_v2</cite>, <cite>other_v3</cite>,
<cite>other_w</cite>. The reason why the elements of quaternion <cite>q</cite> are
passed one by one is efficiency: in this way, the caller does not
have to allocate a numpy.array for simple quaternions (like the
ones returned by <a class="reference internal" href="#litebird_sim.scanning.qrotation_x" title="litebird_sim.scanning.qrotation_x"><code class="xref py py-func docutils literal notranslate"><span class="pre">qrotation_x()</span></code></a>, <a class="reference internal" href="#litebird_sim.scanning.qrotation_y" title="litebird_sim.scanning.qrotation_y"><code class="xref py py-func docutils literal notranslate"><span class="pre">qrotation_y()</span></code></a>,
<a class="reference internal" href="#litebird_sim.scanning.qrotation_z" title="litebird_sim.scanning.qrotation_z"><code class="xref py py-func docutils literal notranslate"><span class="pre">qrotation_z()</span></code></a>).</p>
<p>It’s easy to use NumPy quaternions for <cite>q</cite> as well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">])</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">])</span>
<span class="n">quat_right_multiply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>  <span class="c1"># Unpack &quot;q&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result:&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>See also <a class="reference internal" href="#litebird_sim.scanning.quat_left_multiply" title="litebird_sim.scanning.quat_left_multiply"><code class="xref py py-func docutils literal notranslate"><span class="pre">quat_left_multiply()</span></code></a> for the computation <span class="math notranslate nohighlight">\(r =
q   imes r\)</span>.</p>
</dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.rotate_vector">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">rotate_vector</code><a class="headerlink" href="#litebird_sim.scanning.rotate_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate a vector using a quaternion</p>
<p>Applies a rotation, encoded through the quaternion <cite>vx, vy, vz,
vw</cite>, to the vector <cite>vect</cite> (a 3-element NumPy array), storing the
result in <cite>result</cite> (again a 3-element array).</p>
<p>The formula to rotate a vector <cite>v</cite> by a quaternion <cite>(q_v, w)</cite> is
the following: <span class="math notranslate nohighlight">\(v' = v + 2q_v ⨯ (q_v ⨯ v + w v)\)</span>, where
<cite>q_v</cite> is the vector <cite>(vx, vy, vz)</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.rotate_x_vector">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">rotate_x_vector</code><a class="headerlink" href="#litebird_sim.scanning.rotate_x_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the x vector using the quaternion (vx, vy, vz, w)</p>
<p>This function is equivalent to <code class="docutils literal notranslate"><span class="pre">rotate_vector(result,</span> <span class="pre">vx,</span> <span class="pre">vy,</span> <span class="pre">vz,</span>
<span class="pre">w,</span> <span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0])</span></code>, but it’s faster.</p>
</dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.rotate_y_vector">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">rotate_y_vector</code><a class="headerlink" href="#litebird_sim.scanning.rotate_y_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the x vector using the quaternion (vx, vy, vz, w)</p>
<p>This function is equivalent to <code class="docutils literal notranslate"><span class="pre">rotate_vector(result,</span> <span class="pre">vx,</span> <span class="pre">vy,</span> <span class="pre">vz,</span>
<span class="pre">w,</span> <span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">0])</span></code>, but it’s faster.</p>
</dd></dl>

<dl class="attribute">
<dt id="litebird_sim.scanning.rotate_z_vector">
<code class="sig-prename descclassname">litebird_sim.scanning.</code><code class="sig-name descname">rotate_z_vector</code><a class="headerlink" href="#litebird_sim.scanning.rotate_z_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the x vector using the quaternion (vx, vy, vz, w)</p>
<p>This function is equivalent to <code class="docutils literal notranslate"><span class="pre">rotate_vector(result,</span> <span class="pre">vx,</span> <span class="pre">vy,</span> <span class="pre">vz,</span>
<span class="pre">w,</span> <span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">1])</span></code>, but it’s faster.</p>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">LiteBIRD simulation pipeline</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulations.html">Simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="observations.html">Observations</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Scanning strategy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-spacecraft-s-motion">The spacecraft’s motion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#computing-the-spacecraft-s-orientation">Computing the spacecraft’s orientation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interpretation-of-pointings">Interpretation of pointings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#custom-scanning-strategies">Custom scanning strategies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-litebird_sim.scanning">API reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="imo.html">The Instrument Model Database (IMO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpi.html">Using MPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="integrating.html">Integrating existing codes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="observations.html" title="previous chapter">Observations</a></li>
      <li>Next: <a href="imo.html" title="next chapter">The Instrument Model Database (IMO)</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, The LiteBIRD Simulation Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/scanning.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>